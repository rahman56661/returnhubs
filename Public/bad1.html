<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Returnhubs with Video Recording</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/video.js/7.10.2/video-js.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/video.js/7.10.2/video.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        /* INDUSTRIAL THEME CSS - Only colors and visual styles changed */
        :root {
            --primary-color: #cccccc;
            --secondary-color: #999999;
            --accent-color: #ff4444;
            --dark-bg: #1a1a1a;
            --dark-surface: #2a2a2a;
            --dark-card: #222222;
            --light-text: #e6e6e6;
            --muted-text: #888888;
            --border-color: #444444;
            --success-color: #44ff44;
            --warning-color: #ffaa00;
            --border-radius: 6px;
            --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            --code-font: 'Arial', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: var(--code-font);
        }

        body {
            background: var(--dark-bg);
            min-height: 100vh;
            color: var(--light-text);
            position: relative;
            overflow-x: hidden;
        }

        /* Animated background elements - Industrial Style */
        .bg-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(42, 42, 42, 0.7) 1px, transparent 1px),
                linear-gradient(90deg, rgba(42, 42, 42, 0.7) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: -1;
            opacity: 0.3;
        }

        .floating-code {
            position: absolute;
            color: rgba(136, 136, 136, 0.1);
            font-size: 14px;
            z-index: -1;
            user-select: none;
        }

        .header-bar {
            background: var(--dark-card);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--box-shadow);
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .header-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), var(--warning-color));
        }

        .back-btn {
            background: linear-gradient(to bottom, #555 0%, #444 50%, #333 100%);
            color: var(--light-text);
            border: 1px solid var(--border-color);
            padding: 10px 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 12px;
        }

        .back-btn:hover {
            background: linear-gradient(to bottom, #666 0%, #555 50%, #444 100%);
            border-color: var(--accent-color);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
            transform: translateY(-2px);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
        }

        .main-content {
            background: var(--dark-card);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            padding: 30px;
            box-shadow: var(--box-shadow);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .main-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), var(--warning-color));
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .status-panel {
            background: var(--dark-card);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--box-shadow);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .status-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), var(--warning-color));
        }

        .awb-section {
            margin-bottom: 30px;
            padding: 20px;
            background: var(--dark-surface);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            border: 1px solid var(--border-color);
        }

        .awb-section h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .awb-input {
            width: 100%;
            padding: 14px 15px;
            background-color: var(--dark-surface);
            color: var(--light-text);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: all 0.3s;
            font-family: var(--code-font);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        .awb-input:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow:
                inset 0 2px 4px rgba(0, 0, 0, 0.5),
                0 0 15px rgba(255, 68, 68, 0.3);
        }

        .awb-input::placeholder {
            color: var(--muted-text);
            font-family: var(--code-font);
        }

        .stream-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--dark-surface);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            border: 1px solid var(--border-color);
        }

        .stream-section h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
            text-align: center;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stream-controls {
            display: flex;
            gap: 10px;
        }

        .stream-input {
            flex: 1;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 14px;
            background: var(--dark-surface);
            color: var(--light-text);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .stream-input::placeholder {
            color: var(--muted-text);
        }

        .stream-input:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow:
                inset 0 2px 4px rgba(0, 0, 0, 0.5),
                0 0 15px rgba(255, 68, 68, 0.3);
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            white-space: nowrap;
            color: var(--light-text);
            font-family: var(--code-font);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: linear-gradient(to bottom, #555 0%, #444 50%, #333 100%);
            border: 1px solid var(--border-color);
        }

        .btn-success {
            background: linear-gradient(to bottom, #555 0%, #444 50%, #333 100%);
            border: 1px solid var(--border-color);
        }

        .btn-warning {
            background: linear-gradient(to bottom, #555 0%, #444 50%, #333 100%);
            border: 1px solid var(--border-color);
        }

        .btn-danger {
            background: linear-gradient(to bottom, #555 0%, #444 50%, #333 100%);
            border: 1px solid var(--border-color);
        }

        .btn:hover:not(:disabled) {
            background: linear-gradient(to bottom, #666 0%, #555 50%, #444 100%);
            border-color: var(--accent-color);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #374a67;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.5;
        }

        .video-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        #cameraStream {
            width: 100%;
            max-height: 400px;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--box-shadow);
            border: 1px solid var(--border-color);
        }

        .categories {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .category {
            background: var(--dark-surface);
            border-radius: var(--border-radius);
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: var(--box-shadow);
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .category::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
        }

        .category:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
        }

        .category.active-category {
            box-shadow: 0 0 0 3px var(--accent-color);
            transform: scale(1.02);
        }

        .category h2 {
            margin: 0 0 15px 0;
            text-align: center;
            padding: 10px;
            border-radius: var(--border-radius);
            color: var(--light-text);
            font-size: 16px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: var(--dark-card);
            border: 1px solid var(--border-color);
        }

        .good h2 {
            border-left: 4px solid var(--success-color);
        }

        .bad h2 {
            border-left: 4px solid var(--accent-color);
        }

        .used h2 {
            border-left: 4px solid var(--warning-color);
        }

        .wrong h2 {
            border-left: 4px solid var(--muted-text);
        }

        .category-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 14px;
            transition: all 0.3s ease;
            margin-bottom: 15px;
            background: var(--dark-surface);
            color: var(--light-text);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .category-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow:
                inset 0 2px 4px rgba(0, 0, 0, 0.5),
                0 0 15px rgba(255, 68, 68, 0.3);
        }

        .category-input:disabled {
            background: var(--dark-surface);
            opacity: 0.6;
            color: var(--muted-text);
        }

        .category-input::placeholder {
            color: var(--muted-text);
        }

        .category ul {
            list-style: none;
            max-height: 150px;
            overflow-y: auto;
        }

        .category li {
            padding: 8px 12px;
            margin-bottom: 5px;
            background: var(--dark-surface);
            border-radius: var(--border-radius);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            border: 1px solid var(--border-color);
        }

        .delete-item-btn {
            background: var(--accent-color);
            color: var(--light-text);
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .delete-item-btn:hover {
            background: #ff6b6b;
            transform: scale(1.1);
        }

        .status-indicator {
            padding: 10px 15px;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
            color: var(--light-text);
            border: 1px solid var(--border-color);
            background: var(--dark-surface);
        }

        .awb-status {
            border-left: 4px solid var(--primary-color);
        }

        .stream-status {
            border-left: 4px solid var(--muted-text);
        }

        .stream-status.connected {
            border-left: 4px solid var(--success-color);
            color: var(--light-text);
            animation: pulse 2s infinite;
        }

        .stream-status.disconnected {
            border-left: 4px solid var(--muted-text);
        }

        .actions-panel {
            background: var(--dark-card);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--box-shadow);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .actions-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), var(--warning-color));
        }

        .action-btn {
            width: 100%;
            padding: 15px;
            margin-bottom: 10px;
            border: none;
            border-radius: var(--border-radius);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--light-text);
            font-family: var(--code-font);
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to bottom, #555 0%, #444 50%, #333 100%);
            border: 1px solid var(--border-color);
        }

        .action-btn:hover {
            background: linear-gradient(to bottom, #666 0%, #555 50%, #444 100%);
            border-color: var(--accent-color);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
            transform: translateY(-2px);
        }

        .save-btn {
            border-left: 4px solid var(--success-color);
        }

        .export-btn {
            border-left: 4px solid var(--primary-color);
            display: none;
        }

        .summary,
        .data-management {
            margin-top: 30px;
            padding: 25px;
            background: var(--dark-card);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .summary::before,
        .data-management::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), var(--warning-color));
        }

        .summary h2,
        .data-management h2 {
            margin-bottom: 20px;
            color: var(--primary-color);
            font-size: 24px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .summary-item,
        .data-item {
            padding: 20px;
            margin-bottom: 15px;
            background: var(--dark-surface);
            border-radius: var(--border-radius);
            position: relative;
            border-left: 4px solid var(--accent-color);
            color: var(--light-text);
            border: 1px solid var(--border-color);
        }

        .delete-batch-btn {
            background: var(--accent-color);
            color: var(--light-text);
            border: none;
            padding: 8px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-left: 10px;
        }

        .delete-batch-btn:hover {
            background: #ff6b6b;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 68, 68, 0.4);
        }

        .button-container {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }

        .awb-folder-btn {
            background: var(--dark-surface);
            color: var(--light-text);
            border: 1px solid var(--border-color);
            padding: 8px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-left: 10px;
        }

        .awb-folder-btn:hover {
            background: var(--dark-card);
            border-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 68, 68, 0.3);
        }

        .confirmation-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--dark-card);
            padding: 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            z-index: 2000;
            /* High z-index venum */
            min-width: 350px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .confirmation-dialog::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), var(--warning-color));
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1500;
            /* Dialog kku mela irukkanum */
            backdrop-filter: blur(5px);
        }

        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: var(--border-radius);
            color: var(--light-text);
            font-weight: 600;
            z-index: 3000;
            box-shadow: var(--box-shadow);
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
        }

        .alert.show {
            opacity: 1;
            transform: translateX(0);
        }

        .alert-success {
            background-color: rgba(68, 255, 68, 0.15);
            color: var(--success-color);
            border-color: var(--success-color);
        }

        .alert-warning {
            background-color: rgba(255, 170, 0, 0.15);
            color: var(--warning-color);
            border-color: var(--warning-color);
        }

        .alert-error {
            background-color: rgba(255, 68, 68, 0.15);
            color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .validation-message {
            color: var(--accent-color);
            font-size: 12px;
            margin-top: 5px;
            display: none;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .categories {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 15px;
            }

            .video-controls {
                grid-template-columns: 1fr;
            }

            .stream-controls {
                flex-direction: column;
            }
        }

        .progress-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .fast-feedback {
            transition: all 0.2s ease-in-out;
        }

        .fast-feedback:active {
            transform: scale(0.95);
        }

        .stream-status.connected {
            border-left: 4px solid var(--success-color);
            animation: pulse 2s infinite;
        }

        .stream-status.disconnected {
            border-left: 4px solid var(--muted-text);
        }

        .stream-status.loading {
            border-left: 4px solid var(--primary-color);
            animation: pulse 1s infinite;
        }

        .stream-status.error {
            border-left: 4px solid var(--accent-color);
            animation: shake 0.5s ease-in-out;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        #cctvStream {
            width: 100%;
            max-height: 400px;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--box-shadow);
            background-color: #000;
            object-fit: contain;
            border: 1px solid var(--border-color);
        }

        #streamStatusIndicator {
            background: var(--dark-surface);
            color: var(--light-text);
        }

        .upload-progress {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--dark-card);
            padding: 15px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            z-index: 10000;
            max-width: 300px;
            display: none;
            border: 1px solid var(--border-color);
            color: var(--light-text);
        }

        .progress-bar {
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--warning-color));
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .upload-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .toast {
            margin-bottom: 10px;
            padding: 12px 18px;
            border-radius: var(--border-radius);
            color: var(--light-text);
            font-size: 14px;
            font-weight: 600;
            box-shadow: var(--box-shadow);
            animation: fadein 0.3s, fadeout 0.5s 2.5s;
            opacity: 0.95;
            border-left: 4px solid transparent;
        }

        /* Different types */
        .toast-success {
            background-color: rgba(68, 255, 68, 0.15);
            color: var(--success-color);
            border-color: var(--success-color);
        }

        .toast-warning {
            background-color: rgba(255, 170, 0, 0.15);
            color: var(--warning-color);
            border-color: var(--warning-color);
        }

        .toast-error {
            background-color: rgba(255, 68, 68, 0.15);
            color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .toast-info {
            background-color: rgba(136, 136, 136, 0.15);
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        @keyframes fadein {
            from {
                opacity: 0;
            }

            to {
                opacity: 0.95;
            }
        }

        @keyframes fadeout {
            from {
                opacity: 0.95;
            }

            to {
                opacity: 0;
            }
        }

        /* Additional Information Section Styling */
        .status-panel h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-panel label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--light-text);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 12px;
        }

        select.stream-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 14px;
            background: var(--dark-surface);
            color: var(--light-text);
            margin-bottom: 15px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23cccccc' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
        }

        select.stream-input:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow:
                inset 0 2px 4px rgba(0, 0, 0, 0.5),
                0 0 15px rgba(255, 68, 68, 0.3);
        }

        select.stream-input option {
            background-color: var(--dark-card);
            color: var(--light-text);
            padding: 10px;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--dark-surface);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-color);
        }

        /* Add this to your existing CSS */
        button[onclick*="drive-settings"]:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 68, 68, 0.6);
            background: linear-gradient(to bottom, #666 0%, #555 50%, #444 100%);
            border-color: var(--accent-color);
        }

        button[onclick*="drive-settings"]:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(255, 68, 68, 0.4);
        }

        /* SKU Mismatch Section */
        #skuMismatchFields {
            margin-top: 20px;
            padding: 20px;
            background: var(--dark-surface);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
        }

        #skuMismatchFields h3 {
            margin-bottom: 15px;
            text-align: center;
            color: var(--primary-color);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        textarea.stream-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 14px;
            background: var(--dark-surface);
            color: var(--light-text);
            margin-bottom: 15px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
            resize: vertical;
            min-height: 80px;
            font-family: var(--code-font);
        }

        textarea.stream-input:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow:
                inset 0 2px 4px rgba(0, 0, 0, 0.5),
                0 0 15px rgba(255, 68, 68, 0.3);
        }

        textarea.stream-input::placeholder {
            color: var(--muted-text);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 26, 0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--dark-card);
            padding: 30px;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 400px;
            border: 1px solid var(--border-color);
            position: relative;
            box-shadow: var(--box-shadow);
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), var(--warning-color));
        }

        .modal h3 {
            color: var(--primary-color);
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>

<body>
    <div class="header-bar">
        <button class="back-btn" onclick="goBackToDashboard()">
            ‚Üê Back to Dashboard
        </button>
        <h2 style="margin: 0; color: rgba(170, 188, 193, 0.936); font-weight: 600;">Video Recording Interface</h2>
        <button class="back-btn" onclick="openVideoSettings()" style="margin-right: 10px;">
            ‚öôÔ∏è Video Settings
        </button>
        <button class="back-btn" onclick="window.location.href='/drive-settings'">
            ‚öôÔ∏è Drive Settings
        </button>
        <div style="color: rgba(170, 188, 193, 0.936); font-size: 14px;">Returnhubs System</div>
    </div>

    <div class="container">
        <div class="main-content">
            <!-- AWB Number Input Section -->
            <div class="awb-section">
                <h3>Enter AWB Number</h3>
                <input type="text" id="awbNo" class="awb-input" placeholder="Enter AWB Number" />
                <div id="awbValidationMessage" class="validation-message">
                    Please enter AWB Number to proceed
                </div>
            </div>

            <!-- Stream Section -->
            <div class="stream-section">
                <h3>Camera Stream Settings</h3>
                <div class="stream-controls">
                    <select id="streamProtocol" class="stream-input">
                        <option value="http">HTTP (MJPEG)</option>
                        <option value="rtsp">RTSP (CCTV)</option>
                        <option value="usb">USB Webcam</option>
                    </select>
                    <select id="usbDeviceSelect" class="stream-input" style="display: none;">
                        <option value="">Select a webcam</option>
                    </select>
                    <input type="text" id="streamIP" class="stream-input"
                        placeholder="Enter IP (e.g., 192.168.1.76 or 192.168.1.76:8080)" />
                    <input type="text" id="streamPath" class="stream-input"
                        placeholder="Stream path (e.g., /video for MJPEG)" style="display: none;" />
                    <button class="btn btn-primary" id="updateStream">Update Stream</button>
                    <button class="btn btn-success" id="startStream">Start Stream</button>
                </div>
            </div>


            <!-- Video Controls -->
            <div class="video-controls">
                <button class="btn btn-danger" id="recordOn">üî¥ Start Recording</button>
                <button class="btn btn-warning" id="recordOff" disabled>‚èπ Stop Recording</button>
                <button class="btn btn-success" id="captureImage">üì∑ Capture Image</button>
                <!--<button onclick="testCameraStream()" style="position: fixed; top: 10px; right: 10px; z-index: 10000;">
                        Test Camera
                    </button>-->
            </div>

            <!-- Video Stream -->
            <div class="video-container">
                <img id="cameraStream" src="" alt="MJPEG Stream" style="display: none;" />
                <video id="cctvStream" controls style="display: none; width: 100%; max-height: 400px; 
           border-radius: 15px; margin-bottom: 30px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);"></video>
            </div>

            <!-- Categories -->
            <div class="categories">
                <div class="category good">
                    <h2>GOOD</h2>
                    <input type="text" placeholder="Enter or scan EAN" id="goodscan" class="category-input" disabled />
                    <div class="validation-message">Enter AWB No first</div>
                    <ul id="goodList"></ul>
                </div>
                <div class="category bad">
                    <h2>BAD</h2>
                    <input type="text" placeholder="Enter or scan EAN" id="badscan" class="category-input" disabled />
                    <div class="validation-message">Enter AWB No first</div>
                    <ul id="badList"></ul>
                </div>
                <div class="category used">
                    <h2>USED</h2>
                    <input type="text" placeholder="Enter or scan EAN" id="usedscan" class="category-input" disabled />
                    <div class="validation-message">Enter AWB No first</div>
                    <ul id="usedList"></ul>
                </div>
                <div class="category wrong">
                    <h2>WRONG</h2>
                    <input type="text" placeholder="Enter or scan EAN" id="wrongscan" class="category-input" disabled />
                    <div class="validation-message">Enter AWB No first</div>
                    <ul id="wrongList"></ul>
                </div>

                <div id="skuMismatchFields" style="display: none; margin-top: 20px;">
                    <h3 style="margin-bottom: 15px; text-align: center; color: rgba(170, 188, 193, 0.936);">
                        SKU Mismatch
                    </h3>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <!-- System SKU -->
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #e6e6e6;">System
                                SKU</label>
                            <input type="text" id="systemSku" class="stream-input" placeholder="Enter System SKU" />
                        </div>

                        <!-- Physical SKU -->
                        <div>
                            <label
                                style="display: block; margin-bottom: 5px; font-weight: 600; color: #e6e6e6;">Physical
                                SKU</label>
                            <input type="text" id="physicalSku" class="stream-input" placeholder="Enter Physical SKU"
                                disabled />
                        </div>
                    </div>

                    <!-- Buttons -->
                    <div style="display: flex; gap: 10px; margin-top: 15px; justify-content: flex-end;">
                        <button type="button" id="addSkuPair" class="btn btn-primary">‚ûï Add SKU Pair</button>
                        <button type="button" id="clearSkuList" class="btn btn-warning">üóë Clear SKU List</button>
                    </div>

                    <!-- SKU List -->
                    <ul id="skuPairsList"
                        style="margin-top: 15px; max-height: 150px; overflow-y: auto; list-style: none; padding: 0; border: 1px solid #39394d; border-radius: 10px;">
                        <!-- SKU pairs will be appended here -->
                    </ul>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <!-- Status Panel -->
            <div class="status-panel">
                <div class="status-indicator awb-status">
                    AWB: <span id="currentAwbDisplay">None</span>
                </div>
                <div class="status-indicator stream-status connected" id="streamStatusIndicator">
                    Stream: <span id="streamStatusDisplay">Disconnected</span>
                </div>
            </div>


            <div class="upload-progress" id="uploadProgress">
                <div class="upload-status">
                    <div class="spinner" id="uploadSpinner"></div>
                    <span id="uploadMessage">Uploading to Google Drive...</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div style="font-size: 12px; color: #666;" id="uploadDetails">
                    This may take a moment. You can continue working.
                </div>
            </div>

            <!-- Add this after the Actions Panel but before the Summary section -->
            <div class="status-panel" style="margin-top: 20px;">
                <h3 style="margin-bottom: 15px; text-align: center; color: rgba(170, 188, 193, 0.936);">Additional
                    Information</h3>

                <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                    <!-- Courier Name Dropdown -->
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Courier Name</label>
                        <select id="courierName" class="stream-input" required>
                            <option value="">Select Courier</option>
                            <option value="Amazon">AMAZON</option>
                            <option value="Delhivery">DELHIVERY</option>
                            <option value="Dtdc">DTDC</option>
                            <option value="Ecom">ECOM</option>
                            <option value="Ekart">EKART</option>
                            <option value="Franch Express">FRANCH EXPRESS</option>
                            <option value="India Post">INDIA POST</option>
                            <option value="Shadowfax">SHADOWFAX</option>
                            <option value="Smarter">SMARTER</option>
                            <option value="Tracon">TRACON</option>
                            <option value="Xpressbees">XPRESSBEES</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>

                    <!-- Return Type Dropdown -->
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Return Type</label>
                        <select id="returnType" class="stream-input" required>
                            <option value="">Select Return Type</option>
                            <option value="RTO">RTO</option>
                            <option value="RVP">RVP</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>

                    <!-- OPS Remarks Dropdown -->
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">OPS Remarks</label>
                        <select id="opsRemarks" class="stream-input" required>
                            <option value="">Select OPS Remarks</option>
                            <option value="Other Brand">Other Brand</option>
                            <option value="Good">Good</option>
                            <option value="Damaged">Damaged</option>
                            <option value="Tag Missing">Tag Missing</option>
                            <option value="SKU Mismatch">SKU Mismatch</option>
                            <option value="Missing Items">Missing Items</option>
                            <option value="Size Mismatch">Size Mismatch</option>
                            <option value="Color Mismatch">Color Mismatch</option>
                            <option value="Ean Mismatch">Ean Mismatch</option>
                        </select>
                    </div>

                    <!-- Channel Name -->
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Channel Name</label>
                        <select id="channelName" class="stream-input" required>
                            <option value="">Select Channel Name </option>
                            <option value="Shopify">Shopify</option>
                            <option value=""></option>
                            <option value=""></option>
                            <option value=""></option>
                            <option value=""></option>
                        </select>
                    </div>

                    <!-- Order No Input -->
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Order No</label>
                        <input type="text" id="orderNo" class="stream-input" placeholder="Enter Order No" required />
                        <div id="orderValidationMessage" class="validation-message">Please enter Order No</div>
                    </div>

                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">User Comment</label>
                        <textarea id="userComment" class="stream-input" placeholder="Enter any comments (optional)"
                            rows="3"></textarea>
                    </div>

                </div>
            </div>


            <!-- Actions Panel -->
            <div class="actions-panel">
                <button class="action-btn save-btn" id="savebtn">üíæ Save Data</button>
                <button class="action-btn export-btn" id="exportbtn" disabled>üìä Export to Excel></button>
            </div>
        </div>
    </div>

    <!-- Summary Section 
        <div class="summary">
            <h2>Summary</h2>
            <div id="summaryContent">
                <p style="color: #666; text-align: center; padding: 20px;">No data to display. Start scanning items to see
                    summary.</p>
            </div>
        </div>-->

    <!-- Data Management Section -->
    <div class="data-management">
        <h2>Data Management</h2>
        <div id="dataManagementContent">
            <p style="color: #666; text-align: center; padding: 20px;">No saved data to manage.</p>
        </div>
        <!--  <div class="filter-controls" style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Filter by User:</label>
            <select id="userFilter" class="stream-input">
                <option value="all">All Users</option>
                 Options will be populated dynamically 
            </select>
        </div>-->
    </div>

    <!-- Confirmation Dialog -->
    <div class="overlay" id="confirmationOverlay" style="display: none;"></div>
    <div class="confirmation-dialog" id="confirmationDialog" style="display: none;">
        <h3 style="margin-bottom: 15px; color: var(--primary-color);">Confirmation</h3>
        <p id="confirmationMessage" style="margin-bottom: 25px; color: var(--light-text);"></p>
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button class="btn btn-danger" id="confirmAction">Confirm</button>
            <button class="btn" id="cancelAction"
                style="background: var(--dark-surface); color: var(--light-text);">Cancel</button>
        </div>
    </div>

    <!-- Recording Save Dialog -->
    <div class="overlay" id="saveRecordingOverlay" style="display: none;"></div>
    <div class="confirmation-dialog" id="saveRecordingDialog" style="display: none;">
        <h3 style="margin-bottom: 15px; color: #333;">Save Recording?</h3>
        <p style="margin-bottom: 25px; color: #666;">Do you want to save this recording?</p>
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button class="btn btn-success" id="saveRecordingBtn">üíæ Save</button>
            <button class="btn btn-danger" id="discardRecordingBtn">üóë Discard</button>
        </div>
    </div>

    <!-- Image Save Dialog -->
    <div class="overlay" id="saveImageOverlay" style="display: none;"></div>
    <div class="confirmation-dialog" id="saveImageDialog" style="display: none;">
        <h3 style="margin-bottom: 15px; color: #333;">Save Image?</h3>
        <p style="margin-bottom: 25px; color: #666;">Do you want to save this image?</p>
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button class="btn btn-success" id="saveImageBtn">üíæ Save</button>
            <button class="btn btn-danger" id="discardImageBtn">üóë Discard</button>
        </div>
    </div>

    <!-- Alert Container -->
    <div id="alertContainer"></div>
    <div id="toast-container" style="position: fixed; top: 20px; right: 20px; z-index: 10000;"></div>
    <script>

        // Add this at the top of your script
        let lastAPICallTime = 0;
        const API_CALL_DELAY = 1000;
        // Throttled fetch function
        async function throttledFetch(url, options = {}) {
            const now = Date.now();
            const timeSinceLastCall = now - lastAPICallTime;

            if (timeSinceLastCall < API_CALL_DELAY) {
                await new Promise(resolve => setTimeout(resolve, API_CALL_DELAY - timeSinceLastCall));
            }

            lastAPICallTime = Date.now();
            return fetch(url, options);
        }

        // Add this with other global variables
        let lastAuthCheck = 0;
        const AUTH_CHECK_INTERVAL = 30000; // 30 seconds

        // Modify any periodic auth checks to use this
        async function throttledAuthCheck() {
            const now = Date.now();
            if (now - lastAuthCheck < AUTH_CHECK_INTERVAL) {
                return;
            }
            lastAuthCheck = now;
            // Your auth check code here
        }

        // Function to navigate back to dashboard
        function goBackToDashboard() {
            window.location.href = '/dashboard';
        }

        // Global variable for the server's base URL
        let API_BASE_URL = '';

        // Listen for configuration from parent frame
        window.addEventListener('message', function (event) {
            if (event.data && event.data.type === 'CONFIG') {
                API_BASE_URL = event.data.apiBaseUrl;
                console.log("API Base URL set to:", API_BASE_URL);
            }
        });

        // Global variables
        let currentCategory = '';
        let isRecording = false;
        let tempData = {
            good: [],
            bad: [],
            used: [],
            wrong: []
        };
        let awbData = {};
        let sessionAwbData = {}; // For session-specific data (summary section)
        let recordings = [];
        let currentScannedData = '';
        let scannedDataHistory = [];
        let streamCheckInterval = null;
        let lastStreamCheck = null;
        const STREAM_CHECK_INTERVAL = 5000;
        let currentStreamAddress = '';
        let workingSessionData = {}; // Store working session data
        let currentOperation = null;
        let operationTimeouts = new Map();
        let pendingRecordingData = null;
        let pendingImageData = null;
        let tempKey = null;
        let isProcessing = false;
        let currentStreamProtocol = 'http';
        let currentStreamPath = '/video';
        let usbStream = null;
        let usbRecorder = null;
        let usbRecordedChunks = [];
        let additionalInfo = {
            courierName: '',
            returnType: '',
            opsRemarks: '',
            channelName: '',
            userComment: ''
        };
        let activeUploads = 0;
        let uploadProgressInterval = null;
        let skuPairs = [];

        // For delete confirmation
        let pendingDeleteAction = null;
        let isSaveAction = false;

        // Auto-logout detection variables
        let isPageVisible = true;
        let logoutTimer = null;
        let activityTimer = null;
        const INACTIVITY_TIMEOUT = 30 * 60 * 1000; // 30 minutes
        const LOGOUT_CHECK_INTERVAL = 5000; // 5 seconds

        // DOM elements
        const awbNoInput = document.getElementById('awbNo');
        const goodList = document.getElementById('goodList');
        const badList = document.getElementById('badList');
        const usedList = document.getElementById('usedList');
        const wrongList = document.getElementById('wrongList');
        const summaryContent = document.getElementById('summaryContent');
        const dataManagementContent = document.getElementById('dataManagementContent');
        const categoryInputs = document.querySelectorAll('.category-input');
        const currentAwbDisplay = document.getElementById('currentAwbDisplay');
        const streamStatusIndicator = document.getElementById('streamStatusIndicator');
        const streamStatusDisplay = document.getElementById('streamStatusDisplay');
        const cameraStream = document.getElementById('cameraStream');
        const confirmationDialog = document.getElementById('confirmationDialog');
        const confirmationOverlay = document.getElementById('confirmationOverlay');
        const confirmationMessage = document.getElementById('confirmationMessage');
        const confirmActionBtn = document.getElementById('confirmAction');
        const cancelActionBtn = document.getElementById('cancelAction');
        const streamIPInput = document.getElementById('streamIP');
        const saveRecordingDialog = document.getElementById('saveRecordingDialog');
        const saveRecordingOverlay = document.getElementById('saveRecordingOverlay');
        const saveRecordingBtn = document.getElementById('saveRecordingBtn');
        const discardRecordingBtn = document.getElementById('discardRecordingBtn');
        const saveImageDialog = document.getElementById('saveImageDialog');
        const saveImageOverlay = document.getElementById('saveImageOverlay');
        const saveImageBtn = document.getElementById('saveImageBtn');
        const discardImageBtn = document.getElementById('discardImageBtn');
        const systemSkuInput = document.getElementById('systemSku');
        const physicalSkuInput = document.getElementById('physicalSku');
        const skuPairsList = document.getElementById('skuPairsList');
        const addSkuPairBtn = document.getElementById('addSkuPair');
        const clearSkuListBtn = document.getElementById('clearSkuList');
        const saveBtn = document.getElementById('savebtn');




        // Enable physical SKU input only when system SKU is filled
        systemSkuInput.addEventListener('input', () => {
            physicalSkuInput.disabled = !systemSkuInput.value.trim();
        });

        // Add SKU pair
        addSkuPairBtn.addEventListener('click', () => {
            const systemSku = systemSkuInput.value.trim();
            const physicalSku = physicalSkuInput.value.trim();

            if (!systemSku || !physicalSku) {
                showAlert('Both System SKU and Physical SKU are required', 'error');
                return;
            }

            skuPairs.push({ systemSku, physicalSku });
            renderSkuPairs();
            systemSkuInput.value = '';
            physicalSkuInput.value = '';
            physicalSkuInput.disabled = true;
        });

        // Clear SKU list
        clearSkuListBtn.addEventListener('click', () => {
            skuPairs = [];
            renderSkuPairs();
        });

        // Render SKU pairs
        function renderSkuPairs() {
            skuPairsList.innerHTML = '';
            skuPairs.forEach((pair, index) => {
                const li = document.createElement('li');
                li.style.display = 'flex';
                li.style.justifyContent = 'space-between';
                li.style.padding = '8px 12px';
                li.style.marginBottom = '5px';
                li.style.background = 'rgba(30,31,48,0.9)';
                li.style.borderRadius = '8px';
                li.style.border = '1px solid #39394d';
                li.innerHTML = `
            <span>${pair.systemSku} ‚ûî ${pair.physicalSku}</span>
            <button class="delete-item-btn" data-index="${index}">√ó</button>
        `;
                skuPairsList.appendChild(li);
            });

            // Attach delete events
            document.querySelectorAll('.delete-item-btn').forEach(btn => {
                btn.addEventListener('click', e => {
                    const idx = e.target.dataset.index;
                    skuPairs.splice(idx, 1);
                    renderSkuPairs();
                });
            });
        }



        document.getElementById('opsRemarks').addEventListener('change', function () {
            if (this.value === "SKU Mismatch") {
                document.getElementById('skuMismatchFields').style.display = "block";
            } else {
                document.getElementById('skuMismatchFields').style.display = "none";
            }
        });

        document.getElementById('systemSku').addEventListener('keydown', function (e) {
            if (e.key === "Enter" && this.value.trim()) {
                this.disabled = true;
                document.getElementById('physicalSku').disabled = false;
                document.getElementById('physicalSku').focus();
            }
        });

        document.getElementById('physicalSku').addEventListener('keydown', function (e) {
            if (e.key === "Enter" && this.value.trim()) {
                const systemSku = document.getElementById('systemSku').value.trim();
                const physicalSku = this.value.trim();

                skuPairs.push({ systemSku, physicalSku });

                // Show in list
                const li = document.createElement("li");
                li.textContent = `System: ${systemSku} ‚Üí Physical: ${physicalSku}`;
                document.getElementById('skuPairsList').appendChild(li);

                // Reset for next entry
                document.getElementById('systemSku').value = '';
                document.getElementById('physicalSku').value = '';
                document.getElementById('systemSku').disabled = false;
                this.disabled = true;
                document.getElementById('systemSku').focus();
            }
        });

        document.getElementById('clearSkuList').addEventListener('click', function () {
            document.getElementById('skuPairsList').innerHTML = '';
            skuPairs = []; // global array clear pannunga
        });



        // Stream status types
        const StreamStatus = {
            DISCONNECTED: 'disconnected',
            CONNECTED: 'connected',
            LOADING: 'loading',
            ERROR: 'error'
        };

        const cctvStream = document.getElementById('cctvStream');

        cctvStream.addEventListener('playing', () => {
            updateStreamStatus(StreamStatus.CONNECTED, 'Connected to RTSP');
        });

        // =============================================================================
        // AUTO-LOGOUT FUNCTIONALITY - NEW
        // =============================================================================

        function resetActivityTimer() {
            // Just reset the timer without auto-logout logic
            clearTimeout(activityTimer);
        }

        // Track user activity without auto-logout
        const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
        activityEvents.forEach(event => {
            document.addEventListener(event, resetActivityTimer, true);
        });

        // Add detection for browser/tab close
        window.addEventListener('beforeunload', function () {
            preserveStreamState();
            if (navigator.sendBeacon) {
                const data = new URLSearchParams();
                navigator.sendBeacon('/api/page-unload', data);
            }

            // Also try to send via fetch with keepalive
            fetch('/api/page-unload', {
                method: 'POST',
                keepalive: true,
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams()
            }).catch(() => { /* Ignore errors */ });
        });

        // Add detection for system resume using the resume event
        document.addEventListener('resume', function () {
            // System resumed from sleep
            console.log('System resume detected');
            checkSessionValidity();
        });


        // Add this function to show upload progress
        function showUploadProgress(filename, type) {
            activeUploads++;

            const uploadProgress = document.getElementById('uploadProgress');
            const uploadMessage = document.getElementById('uploadMessage');
            const uploadDetails = document.getElementById('uploadDetails');

            uploadMessage.textContent = `Uploading ${type} to Google Drive...`;
            uploadDetails.textContent = `File: ${filename}. You can continue working.`;
            uploadProgress.style.display = 'block';

            // Simulate progress for better UX (since we can't get real progress)
            let progress = 0;
            const progressFill = document.getElementById('progressFill');

            if (!uploadProgressInterval) {
                uploadProgressInterval = setInterval(() => {
                    if (progress < 90) {
                        progress += 5;
                        progressFill.style.width = `${progress}%`;
                    }
                }, 1000);
            }
        }


        // Add this function to hide upload progress
        function hideUploadProgress() {
            activeUploads--;

            if (activeUploads <= 0) {
                activeUploads = 0;
                const uploadProgress = document.getElementById('uploadProgress');
                const progressFill = document.getElementById('progressFill');

                progressFill.style.width = '100%';

                setTimeout(() => {
                    uploadProgress.style.display = 'none';
                    progressFill.style.width = '0%';
                    if (uploadProgressInterval) {
                        clearInterval(uploadProgressInterval);
                        uploadProgressInterval = null;
                    }
                }, 1000);
            }
        }

        // Add this function to show upload error
        function showUploadError(filename, error) {
            activeUploads--;

            const uploadProgress = document.getElementById('uploadProgress');
            const uploadMessage = document.getElementById('uploadMessage');
            const progressFill = document.getElementById('progressFill');

            uploadMessage.textContent = `Upload failed: ${filename}`;
            progressFill.style.background = 'linear-gradient(45deg, #ff6b6b, #ee5a24)';

            setTimeout(() => {
                uploadProgress.style.display = 'none';
                progressFill.style.width = '0%';
                progressFill.style.background = 'linear-gradient(45deg, #667eea, #764ba2)';
                if (uploadProgressInterval) {
                    clearInterval(uploadProgressInterval);
                    uploadProgressInterval = null;
                }

                showToast(`Google Drive upload failed: ${error}`, 'error');
            }, 3000);
        }

        // Add user filter functionality
        async function populateUserFilter() {
            try {
                const response = await fetch('/api/get-all-users');
                const result = await response.json();

                if (result.success) {
                    const userFilter = document.getElementById('userFilter');
                    userFilter.innerHTML = '<option value="all">All Users</option>';

                    result.users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user._id;
                        option.textContent = user.username;
                        userFilter.appendChild(option);
                    });

                    // Add event listener for filtering
                    userFilter.addEventListener('change', updateDataManagementSection);
                }
            } catch (error) {
                console.error('Error populating user filter:', error);
            }
        }

        // Protocol change handler
        document.getElementById('streamProtocol').addEventListener('change', async function () {
            currentStreamProtocol = this.value;
            const pathInput = document.getElementById('streamPath');
            const ipInput = document.getElementById('streamIP');
            const usbSelect = document.getElementById('usbDeviceSelect');

            if (currentStreamProtocol === 'rtsp') {
                pathInput.style.display = 'block';
                ipInput.style.display = 'block';
                usbSelect.style.display = 'none';
                ipInput.placeholder = 'Enter IP (e.g., 192.168.1.213:554)';
            } else if (currentStreamProtocol === 'http') {
                pathInput.style.display = 'none';
                ipInput.style.display = 'block';
                usbSelect.style.display = 'none';
                ipInput.placeholder = 'Enter IP (e.g., 192.168.1.76 or 192.168.1.76:8080)';
            } else if (currentStreamProtocol === 'usb') {
                pathInput.style.display = 'none';
                ipInput.style.display = 'none';
                usbSelect.style.display = 'block';

                // Load webcams
                try {
                    // üîë First request minimal access to unlock device labels
                    await navigator.mediaDevices.getUserMedia({ video: true });
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoInputs = devices.filter(d => d.kind === 'videoinput');

                    usbSelect.innerHTML = '';

                    if (videoInputs.length > 0) {
                        videoInputs.forEach((device, index) => {
                            const option = document.createElement('option');
                            option.value = device.deviceId;
                            option.textContent = device.label || `Camera ${index + 1}`;
                            usbSelect.appendChild(option);
                        });

                        // Select the first device by default
                        usbSelect.value = videoInputs[0].deviceId;
                    } else {
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = 'No webcam detected';
                        usbSelect.appendChild(option);
                    }
                } catch (err) {
                    console.error('Error fetching webcams:', err);
                    usbSelect.innerHTML = '<option value="">Error detecting webcams</option>';
                }
            }

            saveWorkingSessionData();
        });

        async function startUsbStream() {
            const usbSelect = document.getElementById('usbDeviceSelect');
            const deviceId = usbSelect.value;

            try {
                // Try with deviceId
                usbStream = await navigator.mediaDevices.getUserMedia({
                    video: { deviceId: { exact: deviceId } },
                    audio: false
                });

                const cctvStream = document.getElementById('cctvStream');
                cctvStream.srcObject = usbStream;
                cctvStream.style.display = 'block';
                document.getElementById('cameraStream').style.display = 'none';

                updateStreamStatus(StreamStatus.CONNECTED, 'Connected to USB Webcam');
                window.currentStreamProtocol = 'usb';
                window.currentStreamAddress = 'usb://local'; // fake address so state persists
                preserveStreamState();
            } catch (err) {
                console.error('Error starting USB webcam stream with deviceId:', err);
                updateStreamStatus(StreamStatus.ERROR, 'USB Webcam Error');

                console.warn("Retrying with facingMode...");
                // Get selected option label
                const label = usbSelect.options[usbSelect.selectedIndex].text.toLowerCase();

                if (label.includes("back")) {
                    usbStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: { exact: "environment" } },
                        audio: false
                    });
                } else {
                    usbStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: { exact: "user" } },
                        audio: false
                    });
                }
            }

            // Attach stream if success
            const cctvStream = document.getElementById('cctvStream');
            cctvStream.srcObject = usbStream;
            cctvStream.style.display = 'block';
            document.getElementById('cameraStream').style.display = 'none';

            updateStreamStatus(StreamStatus.CONNECTED, 'Connected to USB Webcam');
            window.currentStreamProtocol = 'usb';
            window.currentStreamAddress = 'usb://local';
            preserveStreamState();
        }






        // Check session validity
        async function checkSessionValidity() {
            try {
                const response = await throttledFetch('/dashboard', {
                    method: 'HEAD',
                    credentials: 'include'
                });

                if (response.status === 401 || !response.ok) {
                    handleAutoLogout('Session expired');
                }
            } catch (error) {
                console.error('Session check failed:', error);
                // Don't auto-logout on network errors, just log
            }
        }

        // Detect browser/tab closing
        function handleBeforeUnload(event) {
            // Save working session data
            saveWorkingSessionData();

            // Modern browsers limit what we can do here
            // The actual logout will be handled by session timeout on server
            console.log('Page unloading - session will be cleaned up by server');
        }

        // =============================================================================
        // WORKING SESSION DATA MANAGEMENT - NEW
        // =============================================================================

        // Load working session data from server
        async function loadWorkingSessionData() {
            try {
                const response = await throttledFetch('/api/get-working-session');
                const result = await response.json();

                if (result.success && result.data) {
                    if (result.data.version > workingSessionData.version) {
                        workingSessionData = result.data;

                        // Restore UI state
                        if (workingSessionData.tempData) {
                            tempData = workingSessionData.tempData;
                            updateAllLists();
                        }

                        if (workingSessionData.currentAwbNo) {
                            awbNoInput.value = workingSessionData.currentAwbNo;
                            currentAwbDisplay.textContent = workingSessionData.currentAwbNo;
                            enableCategoryInputs();
                        }

                        if (workingSessionData.streamIP) {
                            streamIPInput.value = workingSessionData.streamIP;
                        }

                        // Restore additional info if available
                        if (workingSessionData.additionalInfo) {
                            additionalInfo = workingSessionData.additionalInfo;
                            document.getElementById('courierName').value = additionalInfo.courierName || '';
                            document.getElementById('returnType').value = additionalInfo.returnType || '';
                            document.getElementById('opsRemarks').value = additionalInfo.opsRemarks || '';
                            document.getElementById('channelName').value = additionalInfo.channelName || '';
                        }

                        // ENHANCED STREAM RESTORATION
                        if (workingSessionData.streamConnected && workingSessionData.currentStreamAddress) {
                            currentStreamAddress = workingSessionData.currentStreamAddress;
                            const streamUrl = `/video-proxy?camera=${formattedAddress}&path=${encodeURIComponent(currentStreamPath)}&t=${Date.now()}`;
                            cameraStream.src = streamUrl;

                            // Restore the stream status immediately
                            if (workingSessionData.streamStatus === 'connected') {
                                lastStreamCheck = StreamStatus.CONNECTED;
                                updateStreamStatus(StreamStatus.CONNECTED, 'Connected');
                                startStreamMonitoring();
                            }

                            console.log('Stream restored from session data');
                        }

                        if (workingSessionData.recordings) {
                            recordings = workingSessionData.recordings;
                        }

                        console.log('Working session data loaded from server');
                    }
                } else {
                    console.log('No working session data found on server');
                }
            } catch (error) {
                console.error('Error loading working session data:', error);
                showAlert('Error loading session data.', 'error');
            }
        }

        // Add event listeners for the dropdowns
        document.getElementById('courierName').addEventListener('change', function () {
            additionalInfo.courierName = this.value;
            saveWorkingSessionData();
        });

        document.getElementById('returnType').addEventListener('change', function () {
            additionalInfo.returnType = this.value;
            saveWorkingSessionData();
        });

        document.getElementById('opsRemarks').addEventListener('change', function () {
            additionalInfo.opsRemarks = this.value;
            saveWorkingSessionData();
        });

        document.getElementById('channelName').addEventListener('change', function () {
            additionalInfo.channelName = this.value;
            saveWorkingSessionData();
        });


        // Save working session data to server
        async function saveWorkingSessionData() {
            try {
                const sessionData = {
                    tempData: tempData,
                    currentAwbNo: awbNoInput.value.trim(),
                    streamIP: streamIPInput.value.trim(),
                    currentScannedData: currentScannedData,
                    isRecording: isRecording,
                    streamConnected: currentStreamAddress !== '', // Better detection
                    currentStreamAddress: currentStreamAddress, // ADD THIS LINE
                    streamStatus: lastStreamCheck, // ADD THIS LINE to preserve status
                    additionalInfo: additionalInfo,
                    version: Date.now()
                };

                const response = await throttledFetch('/api/update-working-session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(sessionData)
                });

                const result = await response.json();
                if (result.success) {
                    console.log('Working session data saved to server');
                } else {
                    console.error('Failed to save working session data:', result.message);
                }
            } catch (error) {
                console.error('Error saving working session data:', error);
                showAlert('Error saving session data.', 'error');
            }
        }

        // Save stream state before page unload
        window.addEventListener('beforeunload', function () {
            preserveStreamState();
            if (window.currentStreamAddress) {
                localStorage.setItem('streamState', JSON.stringify({
                    address: window.currentStreamAddress,
                    timestamp: Date.now()
                }));
            }
        });

        // Handle page visibility change
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden) {
                // Page visible ah vanthu - refresh dropdowns
                updateDropdownsFromSettings();
            }
        });

        // Reconnect stream function
        function reconnectStream() {
            const streamState = localStorage.getItem('streamState');
            if (streamState) {
                const state = JSON.parse(streamState);
                // Only reconnect if the state is recent (within 5 minutes)
                if (Date.now() - state.timestamp < 300000) {
                    const streamIPInput = document.getElementById('streamIP');
                    if (streamIPInput && state.address) {
                        // Extract IP from the saved address (remove port if present)
                        const ipParts = state.address.split(':');
                        streamIPInput.value = ipParts[0];

                        // Trigger stream connection after a short delay
                        setTimeout(() => {
                            if (window.connectToStream) {
                                window.connectToStream();
                            }
                        }, 500);
                    }
                }
            }
        }

        // Attempt to reconnect when page loads
        document.addEventListener('DOMContentLoaded', function () {
            loadUserInfo();
            // Wait a bit before attempting to restore stream
            setTimeout(() => {
                restoreStreamState();
            }, 300);
        });

        // =============================================================================
        // UTILITY FUNCTIONS
        // =============================================================================

        // ADD a stream state preservation utility function
        function preserveStreamState() {
            if (currentStreamAddress) {
                localStorage.setItem('streamStatePreserve', JSON.stringify({
                    address: currentStreamAddress,
                    protocol: currentStreamProtocol,
                    path: document.getElementById('streamPath').value,
                    status: lastStreamCheck,
                    timestamp: Date.now()
                }));
            }
        }

        // ADD a stream state restoration utility function
        function restoreStreamState() {
            const preserved = localStorage.getItem('streamStatePreserve');
            if (preserved) {
                try {
                    const state = JSON.parse(preserved);

                    // Only restore if recent (within 30 seconds)
                    if (Date.now() - state.timestamp < 30000) {
                        currentStreamAddress = state.address;
                        currentStreamProtocol = state.protocol || 'http';
                        lastStreamCheck = state.status;

                        // Set UI elements
                        streamIPInput.value = state.address;
                        document.getElementById('streamProtocol').value = state.protocol || 'http';

                        if (state.protocol === 'rtsp') {
                            document.getElementById('streamPath').style.display = 'block';
                            if (state.path) {
                                document.getElementById('streamPath').value = state.path;
                            }
                        }

                        if (state.status === StreamStatus.CONNECTED) {
                            if (state.protocol === 'http') {
                                cameraStream.src = `http://${state.address}/video?t=${Date.now()}`;
                                document.getElementById('cctvStream').style.display = 'none';
                                document.getElementById('cameraStream').style.display = 'block';
                            } else {
                                // For RTSP, we need to reinitialize
                                connectToStream();
                            }

                            updateStreamStatus(StreamStatus.CONNECTED, 'Connected');
                            startStreamMonitoring();
                        }

                        console.log('Stream state restored from preservation');
                    }
                } catch (e) {
                    console.error('Error restoring preserved stream state:', e);
                }
            }
        }

        // Show alert function
        function showAlert(message, type = 'success', duration = 3000) {
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;

            const alertContainer = document.getElementById('alertContainer');
            alertContainer.appendChild(alert);

            // Show alert
            setTimeout(() => alert.classList.add('show'), 100);

            // Hide and remove alert
            setTimeout(() => {
                alert.classList.remove('show');
                setTimeout(() => alertContainer.removeChild(alert), 300);
            }, duration);
        }

        // Check if AWB number is entered
        function isAwbEntered() {
            return awbNoInput.value.trim() !== '';
        }

        // Show validation message
        function showAwbValidation() {
            const validationMessage = document.getElementById('awbValidationMessage');
            validationMessage.style.display = 'block';

            // Also show validation for category inputs
            document.querySelectorAll('.category .validation-message').forEach(msg => {
                msg.style.display = 'block';
            });

            setTimeout(() => {
                validationMessage.style.display = 'none';
                document.querySelectorAll('.category .validation-message').forEach(msg => {
                    msg.style.display = 'none';
                });
            }, 3000);
        }

        // Update stream status display
        function updateStreamStatus(status, message) {
            streamStatusDisplay.textContent = message;
            streamStatusIndicator.className = 'status-indicator stream-status' + status;

            // Remove all status classes first
            streamStatusIndicator.classList.remove('connected', 'disconnected', 'loading', 'error');

            // Add the appropriate class
            switch (status) {
                case StreamStatus.CONNECTED:
                    streamStatusIndicator.classList.add('connected');

                    // Add latency indicator for RTSP
                    if (currentStreamProtocol === 'rtsp') {
                        if (message.includes('Low-Latency')) {
                            streamStatusDisplay.textContent += ' üöÄ';
                        } else if (message.includes('Direct')) {
                            streamStatusDisplay.textContent += ' ‚ö°';
                        } else {
                            streamStatusDisplay.textContent += ' ‚è±Ô∏è';
                        }
                    }

                    // Save to localStorage for persistence
                    if (window.currentStreamAddress) {
                        localStorage.setItem('streamState', JSON.stringify({
                            address: window.currentStreamAddress,
                            protocol: currentStreamProtocol,
                            timestamp: Date.now()
                        }));
                    }
                    break;
                case StreamStatus.DISCONNECTED:
                    streamStatusIndicator.classList.add('disconnected');
                    break;
                case StreamStatus.LOADING:
                    // Keep default styling for loading
                    break;
                case StreamStatus.ERROR:
                    streamStatusIndicator.classList.add('error');
                    break;
            }
        }

        function clearStreamState() {
            localStorage.removeItem('streamState');
            window.currentStreamAddress = '';
        }

        // Add this function to check stream health
        function checkStreamHealth() {
            if (!window.hlsInstance || currentStreamProtocol !== 'rtsp') return;

            const video = document.getElementById('cctvStream');

            // Check if video is playing but stalled
            if (video.readyState === 4 && video.paused) {
                console.log('Video appears to be stalled, attempting recovery...');
                //  showDebugInfo('Video stalled, recovering...');

                try {
                    video.play().catch(e => {
                        console.log('Play failed, restarting stream...');
                        // Full stream restart
                        window.hlsInstance.destroy();
                        setTimeout(() => {
                            connectToStream();
                        }, 2000);
                    });
                } catch (e) {
                    console.error('Recovery failed:', e);
                }
            }

            // Check buffer health
            if (window.hlsInstance && window.hlsInstance.media) {
                const bufferInfo = window.hlsInstance.media.buffered;
                if (bufferInfo.length === 0) {
                    console.log('No buffer available, may need to restart');
                    //  showDebugInfo('No buffer, checking stream...');
                }
            }
        }

        // Run health check every 5 seconds
        setInterval(checkStreamHealth, 5000);

        // Check if stream is responsive
        // In bad1.html - Update the stream health check
        async function checkStreamHealth() {
            if (!cameraStream.src || cameraStream.src === '' || !currentStreamAddress) {
                return StreamStatus.DISCONNECTED;
            }

            try {
                // Check if the actual stream image has dimensions (indicating it's working)
                if (cameraStream.naturalWidth > 0 && cameraStream.naturalHeight > 0) {
                    return StreamStatus.CONNECTED;
                }

                // If the main stream doesn't have dimensions, check if it's still loading
                // Wait a bit and check again
                await new Promise(resolve => setTimeout(resolve, 500));

                if (cameraStream.naturalWidth > 0 && cameraStream.naturalHeight > 0) {
                    return StreamStatus.CONNECTED;
                }

                return StreamStatus.ERROR;
            } catch (error) {
                console.error('Stream health check failed:', error);
                return StreamStatus.ERROR;
            }
        }


        // Monitor stream status periodically
        function startStreamMonitoring() {
            if (streamCheckInterval) {
                clearInterval(streamCheckInterval);
            }

            streamCheckInterval = setInterval(async () => {
                // Only check if we think we're connected
                if (lastStreamCheck === StreamStatus.CONNECTED) {
                    const status = await checkStreamHealth();

                    // Only update if status actually changed
                    if (status !== lastStreamCheck) {
                        if (status === StreamStatus.CONNECTED) {
                            updateStreamStatus(StreamStatus.CONNECTED, 'Connected');
                        } else if (status === StreamStatus.ERROR) {
                            updateStreamStatus(StreamStatus.ERROR, 'Connection Lost');
                            // Try to automatically reconnect
                            setTimeout(() => {
                                if (currentStreamAddress) {
                                    connectToStream();
                                }
                            }, 5000);
                        }

                        lastStreamCheck = status;
                    }
                }
            }, 15000); // Check every 15 seconds instead of 10
        }

        // Stop stream monitoring
        function stopStreamMonitoring() {
            if (streamCheckInterval) {
                clearInterval(streamCheckInterval);
                streamCheckInterval = null;
            }
        }

        // Handle stream events
        function setupStreamEvents() {
            cameraStream.onload = () => {
                console.log('Stream loaded successfully');
                // Add a small delay to ensure the stream is fully loaded
                setTimeout(() => {
                    updateStreamStatus(StreamStatus.CONNECTED, 'Connected');
                    lastStreamCheck = StreamStatus.CONNECTED;
                    startStreamMonitoring(); // Start monitoring when stream loads
                }, 1000);
            };

            cameraStream.onerror = () => {
                console.error('Stream error occurred');
                updateStreamStatus(StreamStatus.ERROR, 'Connection Error');
                lastStreamCheck = StreamStatus.ERROR;
            };

            cameraStream.onabort = () => {
                console.warn('Stream connection aborted');
                updateStreamStatus(StreamStatus.ERROR, 'Connection Aborted');
                lastStreamCheck = StreamStatus.ERROR;
            };
        }

        // Helper function to format stream address
        function formatStreamAddress(input) {
            let address = input.trim();
            if (address.includes(':')) {
                return address;
            }
            return address + ':8080';
        }

        // Load data from database on page load
        async function loadSavedData() {
            try {
                console.log('Loading saved data...');

                // Load working session data first
                await loadWorkingSessionData();

                // Then load saved data from database
                const response = await throttledFetch('/api/get-inventory');
                const result = await response.json();

                console.log('Database response:', result);

                if (result.success && result.data) {
                    // Process database data for data management section only
                    processDatabaseData(result.data);
                    console.log('Saved data loaded from database:', result.data.length, 'items');
                } else {
                    console.log('No data found in database');
                }
            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        // Add this function to test the camera stream
        async function testCameraStream() {
            const streamIP = prompt('Enter camera IP address:');
            if (!streamIP) return;

            streamIPInput.value = streamIP;
            const connected = await connectToStream();

            if (connected) {
                showToast('Camera stream connected successfully!', 'success');
            } else {
                showToast('Failed to connect to camera stream', 'error');
            }
        }

        // Process data from database (only for data management section)
        function processDatabaseData(dbData) {
            // Reset permanent data structures only
            awbData = {};

            // Convert database format to our app format
            dbData.forEach(item => {
                const key = `${item._id}`;

                // Add to awbData (permanent storage) only
                awbData[key] = {
                    _id: item._id, // Store the ID for deletion
                    good: item.categoryData.good,
                    bad: item.categoryData.bad,
                    used: item.categoryData.used,
                    wrong: item.categoryData.wrong,
                    timestamp: item.timestamp,
                    awbNo: item.awbNo,
                    username: item.username, // Make sure username is included
                    recordings: item.recordings || [],
                    mediaFiles: item.mediaFiles || []
                };
            });

            // Update data management section only
            updateDataManagementSection();
        }

        // Enable/disable category inputs based on AWB input
        function enableCategoryInputs() {
            const isEnabled = isAwbEntered();
            categoryInputs.forEach(input => {
                input.disabled = !isEnabled;
            });
        }

        // Update all lists from tempData
        function updateAllLists() {
            updateList(goodList, tempData.good, 'good');
            updateList(badList, tempData.bad, 'bad');
            updateList(usedList, tempData.used, 'used');
            updateList(wrongList, tempData.wrong, 'wrong');
        }

        function updateList(listElement, items, category) {
            listElement.innerHTML = '';
            items.forEach((item, index) => {
                const listItem = document.createElement('li');
                listItem.innerHTML = `
                        <span>${item}</span>
                        <button class="delete-item-btn" onclick="deleteScannedItem('${category}', ${index})" title="Delete this item">√ó</button>
                    `;
                listElement.appendChild(listItem);
            });
        }

        // Delete a scanned item from temporary storage
        function deleteScannedItem(category, index) {
            showDeleteConfirmation(
                `Are you sure you want to delete "${tempData[category][index]}"?`,
                () => {
                    if (tempData[category] && tempData[category][index]) {
                        tempData[category].splice(index, 1);
                        updateList(
                            document.getElementById(`${category}List`),
                            tempData[category],
                            category
                        );
                        saveWorkingSessionData();
                        showAlert('Item deleted successfully', 'success');
                    }
                },
                false
            );
        }


        function openAwbFolder(folderLink) {
            if (!folderLink || folderLink === 'Folder creation pending' || folderLink === 'Error creating folder') {
                showToast('AWB folder not available yet', 'warning');
                return;
            }
            window.open(folderLink, '_blank');
        }


        // Update data management section (for permanently saved data only)
        async function updateDataManagementSection() {
            dataManagementContent.innerHTML = '<p>Loading...</p>';

            try {
                const response = await fetch('/api/get-inventory');
                const result = await response.json();

                if (!result.success || result.data.length === 0) {
                    dataManagementContent.innerHTML = `
                <p style="color: var(--muted-text); text-align: center; padding: 20px;">
                    No saved data found in your organization.
                </p>
                <p style="color: var(--primary-color); text-align: center; font-size: 14px;">
                    Organization: ${result.organization || 'Unknown'}
                </p>
            `;
                    return;
                }

                dataManagementContent.innerHTML = `
            <div style="background: var(--dark-surface); color: var(--light-text); padding: 15px; border-radius: var(--border-radius); margin-bottom: 20px; text-align: center; border: 1px solid var(--border-color);">
                <h3 style="margin: 0; font-size: 18px; color: var(--primary-color);">üìä Organization: ${result.organization}</h3>
                <p style="margin: 5px 0 0 0; font-size: 14px; color: var(--muted-text);">
                    Total Records: ${result.data.length}
                </p>
            </div>
        `;

                result.data.forEach(record => {
                    const goodCount = record.categoryData?.good?.count || 0;
                    const badCount = record.categoryData?.bad?.count || 0;
                    const usedCount = record.categoryData?.used?.count || 0;
                    const wrongCount = record.categoryData?.wrong?.count || 0;
                    const totalCount = goodCount + badCount + usedCount + wrongCount;

                    const itemDiv = document.createElement('div');
                    itemDiv.classList.add('data-item');
                    itemDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <div><strong>AWB No:</strong> ${record.awbNo}</div>
                        <div><strong>Order ID:</strong> ${record.orderId || 'Not specified'}</div>
                        <div><strong>Courier:</strong> ${record.additionalInfo?.courierName || 'Not specified'}</div>
                        <div><strong>Return Type:</strong> ${record.additionalInfo?.returnType || 'Not specified'}</div>
                        <div><strong>OPS Remarks:</strong> ${record.additionalInfo?.opsRemarks || 'Not specified'}</div>
                    </div>
                    <div>
                        <div><strong>Channel Name:</strong> ${record.additionalInfo?.channelName || 'Not specified'}</div>
                        <div><strong>Organization:</strong> ${record.organization || 'Unknown'}</div>
                        <div><strong>Created by:</strong> ${record.username || 'Unknown User'}</div>
                        <div><strong>Saved on:</strong> ${new Date(record.timestamp).toLocaleString()}</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; text-align: center; margin: 15px 0; padding: 10px; background: var(--dark-surface); border-radius: var(--border-radius); border: 1px solid var(--border-color);">
                    <div>
                        <div style="font-size: 18px; font-weight: bold; color: var(--success-color);">${goodCount}</div>
                        <div style="font-size: 12px; color: var(--muted-text);">Good</div>
                    </div>
                    <div>
                        <div style="font-size: 18px; font-weight: bold; color: var(--accent-color);">${badCount}</div>
                        <div style="font-size: 12px; color: var(--muted-text);">Bad</div>
                    </div>
                    <div>
                        <div style="font-size: 18px; font-weight: bold; color: var(--warning-color);">${usedCount}</div>
                        <div style="font-size: 12px; color: var(--muted-text);">Used</div>
                    </div>
                    <div>
                        <div style="font-size: 18px; font-weight: bold; color: var(--muted-text);">${wrongCount}</div>
                        <div style="font-size: 12px; color: var(--muted-text);">Wrong</div>
                    </div>
                    <div>
                        <div style="font-size: 18px; font-weight: bold; color: var(--primary-color);">${totalCount}</div>
                        <div style="font-size: 12px; color: var(--muted-text);">Total</div>
                    </div>
                </div>

                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
                    <div style="color: var(--muted-text); font-size: 12px;">
                        Last updated: ${new Date(record.timestamp).toLocaleString()}
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="awb-folder-btn" onclick="openAwbFolder('${record.awbFolderLink}')">AWB Folder</button>
                        <button class="delete-batch-btn" onclick="deleteSavedBatch('${record._id}', '${record.awbNo}')">Delete Batch</button>
                    </div>
                </div>
            `;
                    dataManagementContent.appendChild(itemDiv);
                });
            } catch (err) {
                console.error('Error fetching inventory data:', err);
                dataManagementContent.innerHTML = '<p style="color: var(--accent-color);">Error loading data.</p>';
            }
        }


        // Delete a saved batch

        async function deleteSavedBatch(recordId, awbNo) {
            try {
                showDeleteConfirmation(
                    `Are you sure you want to delete batch ${awbNo}?`,
                    async () => {
                        try {
                            // ‚úÖ Use AWB-based delete endpoint
                            const deleteResponse = await fetch(`/api/delete-inventory/awb/${awbNo}`, {
                                method: 'DELETE',
                                credentials: 'include'
                            });

                            console.log('Delete response status:', deleteResponse.status);

                            const result = await deleteResponse.json();
                            console.log('Delete result:', result);

                            if (result.success) {
                                await updateDataManagementSection();
                                showToast('Batch deleted successfully', 'success');
                            } else {
                                showAlert('Failed to delete batch: ' + result.message, 'error');
                            }
                        } catch (error) {
                            console.error('Error deleting batch:', error);
                            showAlert('Error deleting batch: ' + error.message, 'error');
                        }
                    },
                    false
                );
            } catch (error) {
                console.error('Error in delete process:', error);
                showAlert('Error checking permissions', 'error');
            }
        }
        /*
                async function getCurrentOrganization() {
                    try {
                        const response = await fetch('/api/get-current-organization');
                        const result = await response.json();
        
                        if (result.success) {
                            return result.organization;
                        } else {
                            console.error('Failed to get organization:', result.error);
                            return 'default'; // Fallback organization
                        }
                    } catch (error) {
                        console.error('Error getting organization:', error);
                        return 'default'; // Fallback organization
                    }
                }*/

        // Show delete confirmation dialog
        function showDeleteConfirmation(message, confirmCallback, isSave = false) {
            // DOM elements select pannu - idhu correct ah irukka check pannu
            const confirmationDialog = document.getElementById('confirmationDialog');
            const confirmationOverlay = document.getElementById('confirmationOverlay');
            const confirmationMessage = document.getElementById('confirmationMessage');
            const confirmActionBtn = document.getElementById('confirmAction');
            const cancelActionBtn = document.getElementById('cancelAction');

            // Debug: Console la elements print pannu
            console.log('Dialog elements:', {
                confirmationDialog,
                confirmationOverlay,
                confirmationMessage,
                confirmActionBtn,
                cancelActionBtn
            });

            // Elements null ah iruntha stop pannu
            if (!confirmationDialog || !confirmationOverlay || !confirmationMessage || !confirmActionBtn || !cancelActionBtn) {
                console.error('‚ùå Confirmation dialog elements not found in DOM');
                // Fallback - browser confirm use pannu
                const userConfirmed = confirm(message);
                if (userConfirmed && confirmCallback) {
                    confirmCallback();
                }
                return;
            }

            // Rest of your function
            confirmationMessage.textContent = message;
            confirmationDialog.style.display = 'block';
            confirmationOverlay.style.display = 'block';

            pendingDeleteAction = confirmCallback;
            isSaveAction = isSave;

            // Update button text and style based on action type
            if (isSave) {
                confirmActionBtn.textContent = 'üíæ Save';
                confirmActionBtn.className = 'btn btn-success';
            } else {
                confirmActionBtn.textContent = 'üóë Delete';
                confirmActionBtn.className = 'btn btn-danger';
            }

            confirmActionBtn.onclick = function () {
                console.log('Confirm button clicked');
                if (pendingDeleteAction) {
                    pendingDeleteAction();
                }
                hideConfirmationDialog();
            };

            cancelActionBtn.onclick = function () {
                console.log('Cancel button clicked');
                hideConfirmationDialog();
            };

            console.log('‚úÖ Delete confirmation dialog shown');
        }
        /*
                // Add this function to check available DELETE routes
                async function checkDeleteRoutes() {
                    console.log('üîç Checking available DELETE routes...');
        
                    const testRoutes = [
                        '/api/delete-inventory/test-id',
                        '/api/delete-inventory/awb/test-awb',
                        '/api/inventory/test-id',
                        '/api/remove-inventory/test-id'
                    ];
        
                    for (const route of testRoutes) {
                        try {
                            const response = await fetch(route, {
                                method: 'DELETE',
                                credentials: 'include'
                            });
                            console.log(`${route}: ${response.status}`);
                        } catch (error) {
                            console.log(`${route}: ERROR - ${error.message}`);
                        }
                    }
                }
        
                // Call this function in your console
                checkDeleteRoutes();*/

        // Hide confirmation dialog
        function hideConfirmationDialog() {
            const confirmationDialog = document.getElementById('confirmationDialog');
            const confirmationOverlay = document.getElementById('confirmationOverlay');

            if (confirmationDialog) {
                confirmationDialog.style.display = 'none';
                console.log('‚úÖ Dialog hidden');
            }
            if (confirmationOverlay) {
                confirmationOverlay.style.display = 'none';
                console.log('‚úÖ Overlay hidden');
            }

            pendingDeleteAction = null;
            isSaveAction = false;
        }

        // Show save recording dialog
        function showSaveRecordingDialog() {
            saveRecordingDialog.style.display = 'block';
            saveRecordingOverlay.style.display = 'block';

            // Enable both buttons immediately
            saveRecordingBtn.disabled = false;
            discardRecordingBtn.disabled = false;

            saveRecordingBtn.textContent = 'üíæ Save';
            discardRecordingBtn.textContent = 'üóë Discard';

            // Set up button handlers
            saveRecordingBtn.onclick = saveRecording;
            discardRecordingBtn.onclick = discardRecording;
        }

        // Hide save recording dialog
        function hideSaveRecordingDialog() {
            saveRecordingDialog.style.display = 'none';
            saveRecordingOverlay.style.display = 'none';
        }

        // Set current category based on focused input
        function setCurrentCategory() {
            const activeInput = document.activeElement;
            currentCategory = activeInput.id.replace('scan', '');

            // Highlight active category
            categoryInputs.forEach(input => {
                input.parentElement.classList.remove('active-category');
            });
            activeInput.parentElement.classList.add('active-category');
        }

        // Handle category input with scanned data tracking
        function handleCategoryInput(inputElement, listElement, category) {
            function processInput() {
                const barcode = inputElement.value.trim();

                // Validate AWB number
                if (!isAwbEntered()) {
                    showAwbValidation();
                    inputElement.value = '';
                    return;
                }

                const awbNo = awbNoInput.value.trim();

                if (barcode) {
                    // Add barcode to the correct category in tempData
                    tempData[category].push(barcode);

                    // Update the scanned data for folder naming
                    currentScannedData = barcode;
                    scannedDataHistory.push(barcode);

                    // Update the list element to show the scanned barcode
                    updateList(listElement, tempData[category], category);

                    // Save working session data
                    saveWorkingSessionData();

                    inputElement.value = ''; // Clear input field after scan
                    showAlert(`${barcode} added to ${category.toUpperCase()}`, 'success');

                    // Reset activity timer
                    resetActivityTimer();
                }
            }

            // Desktop/Laptop: Enter key
            inputElement.addEventListener('keydown', function (event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    processInput();
                }
            });

            // Mobile: Arrow button (done/next) ‚Üí triggers "change"
            inputElement.addEventListener('change', function () {
                processInput();
            });
        }


        // Handle browser navigation (back/forward)
        window.addEventListener('pageshow', function (event) {
            if (event.persisted) {
                // Page was restored from bfcache, try to reconnect stream
                setTimeout(reconnectStream, 100);
            }
        });

        // Clear stream state when explicitly disconnecting
        function disconnectStream() {
            clearStreamState();
            cameraStream.src = '';
            updateStreamStatus(StreamStatus.DISCONNECTED, 'Disconnected');
            stopStreamMonitoring();
            showToast('Stream disconnected', 'info');
        }

        // Add a disconnect button to your HTML or use existing functionality

        // Initialize the application
        async function initApp() {
            await loadOrganizationDropdowns();
            // Set up stream events
            setupStreamEvents();

            // Set initial stream status
            updateStreamStatus(StreamStatus.DISCONNECTED, 'Disconnected');

            // Check for saved stream state
            const streamState = localStorage.getItem('streamState');
            if (streamState) {
                const state = JSON.parse(streamState);
                // Only auto-reconnect if the state is recent (within 5 minutes)
                if (Date.now() - state.timestamp < 300000) {
                    const ipParts = state.address.split(':');
                    streamIPInput.value = ipParts[0];
                    // Auto-connect after a short delay
                    setTimeout(() => connectToStream(), 500);
                }
            }

            // Load saved data - now from database and working session
            await loadSavedData();
            restoreStreamState();
            // Add event listeners to category inputs
            categoryInputs.forEach(input => {
                input.addEventListener('focus', setCurrentCategory);
            });

            // Initialize category input handlers
            handleCategoryInput(document.getElementById('goodscan'), goodList, 'good');
            handleCategoryInput(document.getElementById('badscan'), badList, 'bad');
            handleCategoryInput(document.getElementById('usedscan'), usedList, 'used');
            handleCategoryInput(document.getElementById('wrongscan'), wrongList, 'wrong');

            // AWB input event listener
            awbNoInput.addEventListener('input', function () {
                const awbValue = this.value.trim();
                currentAwbDisplay.textContent = awbValue || 'None';
                enableCategoryInputs();
                saveWorkingSessionData(); // Save working session data
                resetActivityTimer();
            });

            // Stream IP event listener
            streamIPInput.addEventListener('input', function () {
                saveWorkingSessionData();
                resetActivityTimer();
            });

            console.log('Application initialized successfully');
        }

        // =============================================================================
        // EVENT LISTENERS
        // =============================================================================

        // Update Stream button
        document.getElementById('updateStream').addEventListener('click', function () {
            const streamIP = streamIPInput.value.trim();
            if (streamIP) {
                showToast('Stream URL Updated', 'info');
                saveWorkingSessionData();
            } else {
                showToast('Please enter IP address', 'warning');
            }
        });

        // Start Stream button
        document.getElementById('startStream').addEventListener('click', connectToStream);

        // Recording buttons
        document.getElementById('recordOn').addEventListener('click', startRecording);
        document.getElementById('recordOff').addEventListener('click', stopRecording);
        saveRecordingBtn.addEventListener('click', async () => {
            if (isProcessing) return;

            isProcessing = true;
            saveRecordingBtn.disabled = true;
            saveRecordingBtn.textContent = 'Saving...';

            try {
                await saveRecording();
            } finally {
                isProcessing = false;
                saveRecordingBtn.disabled = false;
                saveRecordingBtn.textContent = 'üíæ Save';
            }
        });

        discardRecordingBtn.addEventListener('click', async () => {
            if (isProcessing) return;

            isProcessing = true;
            discardRecordingBtn.disabled = true;
            discardRecordingBtn.textContent = 'Discarding...';

            try {
                await discardRecording();
            } finally {
                isProcessing = false;
                discardRecordingBtn.disabled = false;
                discardRecordingBtn.textContent = 'üóë Discard';
            }
        });

        // Capture Image
        document.getElementById('captureImage').addEventListener('click', captureFromStream);
        /* document.getElementById('captureImage').addEventListener('click', async () => {
             if (!isAwbEntered()) {
                 showAwbValidation();
                 return;
             }
 
             if (!isStreamConnected()) {
                 showStreamRequiredAlert('capturing image');
                 return;
             }
 
             try {
                 const awbNo = awbNoInput.value.trim();
                 const streamUrl = `http://${currentStreamAddress}/video`;
 
                 const response = await fetch('/api/capture-image', {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({
                         awbNo: awbNo,
                         scannedData: currentScannedData,
                         streamUrl: streamUrl
                     })
                 });
 
                 const result = await response.json();
                 if (result.success) {
                     // Show ONLY "Image captured" toast
                     showToast('Image captured', 'success');
 
                     pendingImageData = {
                         awbNo: awbNo,
                         tempKey: result.tempKey,
                         scannedData: result.scannedData
                     };
 
                     // Show save/discard dialog immediately
                     showSaveImageDialog();
                 } else {
                     showToast('Failed to capture image: ' + result.error, 'error');
                 }
             } catch (error) {
                 console.error('Error capturing image:', error);
                 showToast('Error capturing image: ' + error.message, 'error');
             }
         });*/


        // Save Image
        saveImageBtn.addEventListener('click', async () => {
            if (isProcessing) return;

            isProcessing = true;
            saveImageBtn.disabled = true;
            saveImageBtn.textContent = 'Saving...';

            try {
                await saveImage();
            } finally {
                isProcessing = false;
                saveImageBtn.disabled = false;
                saveImageBtn.textContent = 'üíæ Save';
            }
        });

        // Discard Image
        discardImageBtn.addEventListener('click', async () => {
            if (isProcessing) return;

            isProcessing = true;
            discardImageBtn.disabled = true;
            discardImageBtn.textContent = 'Discarding...';

            try {
                await discardImage();
            } finally {
                isProcessing = false;
                discardImageBtn.disabled = false;
                discardImageBtn.textContent = 'üóë Discard';
            }
        });


        // Save/discard recording buttons
        document.getElementById('saveRecordingBtn').addEventListener('click', saveRecording);
        document.getElementById('discardRecordingBtn').addEventListener('click', discardRecording);

        // Save/discard image buttons
        document.getElementById('saveImageBtn').addEventListener('click', saveImage);
        document.getElementById('discardImageBtn').addEventListener('click', discardImage);

        // Add this CSS to your existing styles in bad1.html:
        const pulseCSS = `
    @keyframes pulse {
        0% { transform: scale(1); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); }
        50% { transform: scale(1.02); box-shadow: 0 12px 48px rgba(79, 172, 254, 0.4); }
        100% { transform: scale(1); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); }
    }
    `;

        // Add the CSS to the document
        const style = document.createElement('style');
        style.textContent = pulseCSS;
        document.head.appendChild(style);

        // Save data - Updated to use database and clear working session
        // In bad1.html - Enhance the save button click handler
        document.getElementById('savebtn').addEventListener('click', async function () {
            const awbNo = awbNoInput.value.trim();
            const orderNo = document.getElementById('orderNo').value.trim();

            // Get the additional information from the dropdowns
            additionalInfo.courierName = document.getElementById('courierName').value;
            additionalInfo.returnType = document.getElementById('returnType').value;
            additionalInfo.opsRemarks = document.getElementById('opsRemarks').value;
            additionalInfo.channelName = document.getElementById('channelName').value;
            additionalInfo.userComment = document.getElementById('userComment').value.trim();

            if (!awbNo) {
                showAlert('Please enter AWB Number before saving.', 'error');
                return;
            }

            if (!orderNo) {
                showAlert('Please enter Order No before saving.', 'error');
                return;
            }

            const totalItems = tempData.good.length + tempData.bad.length +
                tempData.used.length + tempData.wrong.length;

            if (totalItems === 0) {
                showAlert('No items to save. Please scan some items first.', 'error');
                return;
            }

            // Validate that all required fields are filled
            if (!additionalInfo.courierName || !additionalInfo.returnType || !additionalInfo.opsRemarks || !additionalInfo.channelName) {
                showAlert('Please fill all additional information fields (Courier Name, Return Type, OPS Remarks, Channel Name).', 'error');
                return;
            }

            // üÜï NEW VALIDATION: Check if "SKU Mismatch" is selected but no SKU pairs are added
            if (additionalInfo.opsRemarks === "SKU Mismatch") {
                if (skuPairs.length === 0) {
                    showAlert('You selected "SKU Mismatch" but no SKU pairs have been added. Please add at least one System SKU and Physical SKU pair, or change the OPS Remarks.', 'error');
                    // Scroll to SKU section to make it visible
                    document.getElementById('skuMismatchFields').scrollIntoView({ behavior: 'smooth' });
                    return;
                }

                // Additional check: ensure all SKU pairs have both system and physical SKUs
                const incompletePairs = skuPairs.filter(pair => !pair.systemSku.trim() || !pair.physicalSku.trim());
                if (incompletePairs.length > 0) {
                    showAlert('Some SKU pairs are incomplete. Please ensure all pairs have both System SKU and Physical SKU filled.', 'error');
                    return;
                }
            }

            showDeleteConfirmation(
                `Are you sure you want to save ${totalItems} items for AWB ${awbNo}?`,
                async function () {
                    try {
                        // PRESERVE STREAM STATE BEFORE SAVE
                        const wasStreamConnected = currentStreamAddress !== '';
                        const preservedStreamAddress = currentStreamAddress;
                        const preservedStreamStatus = lastStreamCheck;

                        // Disable button and show loading
                        const saveBtn = document.getElementById("savebtn");
                        saveBtn.disabled = true;
                        saveBtn.innerHTML = '<span class="progress-indicator"></span> Saving...';

                        // Prepare category data
                        const categoryData = {
                            good: { count: tempData.good.length, eans: tempData.good },
                            bad: { count: tempData.bad.length, eans: tempData.bad },
                            used: { count: tempData.used.length, eans: tempData.used },
                            wrong: { count: tempData.wrong.length, eans: tempData.wrong }
                        };

                        const awbRecordings = recordings.filter(r => r.awbNo === awbNo);

                        const response = await fetch('/api/save-inventory', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                awbNo: awbNo,
                                orderId: orderNo,
                                categoryData: categoryData,
                                recordings: awbRecordings,
                                additionalInfo: additionalInfo,
                                skuPairs: skuPairs
                            })
                        });

                        const result = await response.json();
                        if (result.success) {
                            // Clear only the form data
                            tempData = { good: [], bad: [], used: [], wrong: [] };
                            recordings = recordings.filter(r => r.awbNo !== awbNo);
                            currentScannedData = '';
                            updateAllLists();

                            // Clear AWB input and update display
                            awbNoInput.value = '';
                            currentAwbDisplay.textContent = 'None';
                            enableCategoryInputs();

                            // Clear additional info dropdowns
                            document.getElementById('courierName').value = '';
                            document.getElementById('returnType').value = '';
                            document.getElementById('opsRemarks').value = '';
                            document.getElementById('channelName').value = '';
                            document.getElementById('orderNo').value = '';
                            document.getElementById('userComment').value = '';
                            additionalInfo = { courierName: '', returnType: '', opsRemarks: '', channelName: '', userComment: '' };

                            // ‚úÖ CLEAR SKU PAIRS AUTOMATICALLY
                            skuPairs = [];
                            renderSkuPairs();
                            systemSkuInput.value = '';
                            physicalSkuInput.value = '';
                            physicalSkuInput.disabled = true;
                            // Hide SKU mismatch fields
                            document.getElementById('skuMismatchFields').style.display = "none";

                            // RESTORE STREAM STATE AFTER SAVE
                            if (wasStreamConnected && preservedStreamAddress) {
                                currentStreamAddress = preservedStreamAddress;
                                lastStreamCheck = preservedStreamStatus;

                                // Ensure stream src is maintained
                                if (cameraStream.src === '' || !cameraStream.src.includes(preservedStreamAddress)) {
                                    cameraStream.src = `http://${preservedStreamAddress}/video?t=${Date.now()}`;
                                }

                                // Restore UI status
                                updateStreamStatus(StreamStatus.CONNECTED, 'Connected');

                                // Resume monitoring if it was stopped
                                if (!streamCheckInterval) {
                                    startStreamMonitoring();
                                }

                                console.log('Stream state preserved after save');
                            }

                            // üî• FIX 1: Force reload data management section immediately
                            if (typeof updateDataManagementSection === "function") {
                                await updateDataManagementSection();
                            } else if (typeof loadSavedData === "function") {
                                await loadSavedData();
                            }

                            // Update working session on server
                            await saveWorkingSessionData();

                            showAlert('Data saved successfully!', 'success');
                        } else {
                            showAlert('Failed to save data: ' + result.message, 'error');
                        }
                    } catch (error) {
                        console.error('Error saving data:', error);
                        showAlert('Error saving data: ' + error.message, 'error');
                    } finally {
                        // Re-enable button
                        const saveBtn = document.getElementById("savebtn");
                        saveBtn.disabled = false;
                        saveBtn.innerHTML = "üíæ Save Data";
                    }
                    resetActivityTimer();
                },
                true
            );
        });



        // Export to Excel - Updated to use database data
        // Enhanced export button function - Replace your existing exportbtn listener
        // In bad1.html - Update the export button click handler
        document.getElementById('exportbtn').addEventListener('click', async function () {
            try {
                console.log('üöÄ Starting data export...');

                // Get data from database
                const response = await fetch('/api/get-inventory');
                const result = await response.json();

                if (!result.success || !result.data || result.data.length === 0) {
                    showAlert('No data to export.', 'error');
                    return;
                }

                console.log('üìä Found data for', result.data.length, 'AWB numbers');

                // Prepare data for export
                const exportData = {
                    summary: result.data.map(item => {
                        const total = item.categoryData.good.count + item.categoryData.bad.count +
                            item.categoryData.used.count + item.categoryData.wrong.count;

                        return {
                            'AWB No': item.awbNo,
                            'Courier Name': item.additionalInfo?.courierName || 'Not specified',
                            'Return Type': item.additionalInfo?.returnType || 'Not specified',
                            'OPS Remarks': item.additionalInfo?.opsRemarks || 'Not specified',
                            'Channel Name': item.additionalInfo?.channelName || 'Not specified',
                            'Good': item.categoryData.good.count,
                            'Bad': item.categoryData.bad.count,
                            'Used': item.categoryData.used.count,
                            'Wrong': item.categoryData.wrong.count,
                            'Total': total,
                            'Date': new Date(item.timestamp).toLocaleString(),
                            'Operator': item.username || 'Unknown User'
                        };
                    }),

                    eanDetails: [],
                    recordings: []
                };

                console.log('üìã Processing EAN details and recordings...');

                // Prepare EAN details
                result.data.forEach(item => {
                    ['good', 'bad', 'used', 'wrong'].forEach(status => {
                        const eanList = item.categoryData[status]?.eans || [];
                        eanList.forEach(ean => {
                            exportData.eanDetails.push({
                                'AWB No': item.awbNo,
                                'Courier Name': item.additionalInfo?.courierName || 'Not specified',
                                'Return Type': item.additionalInfo?.returnType || 'Not specified',
                                'OPS Remarks': item.additionalInfo?.opsRemarks || 'Not specified',
                                'Channel Name': item.additionalInfo?.channelName || 'Not specified',
                                'EAN': ean,
                                'Status': status.charAt(0).toUpperCase() + status.slice(1),
                                'Date': new Date(item.timestamp).toLocaleString(),
                                'Operator': 'Current User'
                            });
                        });
                    });

                    // Enhanced recordings with image file paths
                    if (item.recordings && item.recordings.length > 0) {
                        item.recordings.forEach(recording => {
                            exportData.recordings.push({
                                awbNo: item.awbNo,
                                'Courier Name': item.additionalInfo?.courierName || 'Not specified',
                                'Return Type': item.additionalInfo?.returnType || 'Not specified',
                                'OPS Remarks': item.additionalInfo?.opsRemarks || 'Not specified',
                                'Channel Name': item.additionalInfo?.channelName || 'Not specified',
                                videoFile: recording.videoFile || '',
                                date: new Date(recording.date || item.timestamp).toLocaleString(),
                                originalDate: recording.date || item.timestamp, // Keep original for backend processing
                                scannedData: recording.scannedData || 'None'
                            });
                        });
                    } else {
                        // Even if no recordings, add AWB entry for image scanning
                        exportData.recordings.push({
                            awbNo: item.awbNo,
                            'Courier Name': item.additionalInfo?.courierName || 'Not specified',
                            'Return Type': item.additionalInfo?.returnType || 'Not specified',
                            'OPS Remarks': item.additionalInfo?.opsRemarks || 'Not specified',
                            'Channel Name': item.additionalInfo?.channelName || 'Not specified',
                            videoFile: '',
                            date: new Date(item.timestamp).toLocaleString(),
                            originalDate: item.timestamp,
                            scannedData: 'None'
                        });
                    }
                });

                console.log('üì¶ Export data prepared:');
                console.log('  - Summary items:', exportData.summary.length);
                console.log('  - EAN details:', exportData.eanDetails.length);
                console.log('  - Recording entries:', exportData.recordings.length);

                // Show loading indicator
                const exportBtn = document.getElementById('exportbtn');
                const originalText = exportBtn.textContent;
                exportBtn.textContent = 'Generating Excel...';
                exportBtn.disabled = true;

                // Send data to server to generate Excel
                const excelResponse = await fetch('/generate-excel', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        summaryData: exportData.summary,
                        eanDetailsData: exportData.eanDetails,
                        recordingsData: exportData.recordings
                    })
                });

                // Reset button
                exportBtn.textContent = originalText;
                exportBtn.disabled = false;

                if (!excelResponse.ok) {
                    const errorText = await excelResponse.text();
                    throw new Error(`Server error: ${errorText}`);
                }

                const blob = await excelResponse.blob();

                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `warehouse_export_${new Date().toISOString().split('T')[0]}.xlsx`;
                document.body.appendChild(a);
                a.click();

                // Cleanup
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                }, 100);

                showAlert('Excel exported successfully! üéâ', 'success');
                console.log('‚úÖ Excel export completed successfully');

                resetActivityTimer();

            } catch (error) {
                console.error('‚ùå Error exporting data:', error);
                showAlert('Error exporting data: ' + error.message, 'error');

                // Reset button on error
                const exportBtn = document.getElementById('exportbtn');
                exportBtn.textContent = 'Export to Excel';
                exportBtn.disabled = false;
            }
        });

        // Global functions for deleting items
        window.deleteScannedItem = deleteScannedItem;
        window.deleteSavedBatch = deleteSavedBatch;

        // Load saved data when page loads
        document.addEventListener('DOMContentLoaded', function () {
            // Add HLS.js library dynamically if needed
            const hlsScript = document.createElement('script');
            hlsScript.src = 'https://cdn.jsdelivr.net/npm/hls.js@latest';
            document.head.appendChild(hlsScript);
            initApp();
        });

        // Add keyboard shortcuts
        document.addEventListener('keydown', function (event) {
            resetActivityTimer();

            // Ctrl+B or Cmd+B to go back to dashboard
            if ((event.ctrlKey || event.metaKey) && event.key === 'b') {
                event.preventDefault();
                goBackToDashboard();
            }

            // Ctrl+S or Cmd+S to save data
            if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                event.preventDefault();
                document.getElementById('savebtn').click();
            }

            // Ctrl+R or Cmd+R to start recording (prevent default browser refresh)
            if ((event.ctrlKey || event.metaKey) && event.key === 'r' && !isRecording) {
                event.preventDefault();
                document.getElementById('recordOn').click();
            }


        });

        // Optional: Handle browser back button to go to dashboard
        window.addEventListener('popstate', function (event) {
            if (document.referrer.includes('/dashboard') || document.referrer.includes('/login')) {
                window.location.href = '/dashboard';
            }
        });
        function showToast(message, type = 'success', duration = 3000) {
            // Remove any existing toast first
            const existingToast = document.getElementById('single-toast');
            if (existingToast) {
                existingToast.remove();
            }

            const toast = document.createElement('div');
            toast.id = 'single-toast'; // Give it an ID so we can find it later
            toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            z-index: 10000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.3s ease;
            max-width: 300px;
            word-wrap: break-word;
        `;

            // Set background color based on type
            if (type === 'success') {
                toast.style.background = 'linear-gradient(45deg, #56ab2f, #a8e6cf)';
            } else if (type === 'error') {
                toast.style.background = 'linear-gradient(45deg, #ff6b6b, #ee5a24)';
            } else if (type === 'info') {
                toast.style.background = 'linear-gradient(45deg, #667eea, #764ba2)';
            } else if (type === 'warning') {
                toast.style.background = 'linear-gradient(45deg, #f9d423, #ff4e50)';
                toast.style.color = '#222'; // dark text for better contrast on yellow/orange
            }

            toast.textContent = message;
            document.body.appendChild(toast);

            // Show toast
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(0)';
            }, 100);

            // Auto-dismiss
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100px)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, duration);
        }

        // Check if stream is connected before allowing actions
        function isStreamConnected() {
            // For HTTP streams
            if (currentStreamProtocol === 'http') {
                return currentStreamAddress !== '' && cameraStream.src !== '';
            }

            // For RTSP streams
            else if (currentStreamProtocol === 'rtsp') {
                const video = document.getElementById('cctvStream');
                return currentStreamAddress !== '' && video.src !== '' &&
                    (video.readyState === 4 || video.readyState === 3); // 4 = HAVE_ENOUGH_DATA, 3 = HAVE_FUTURE_DATA
            }

            // üÜï For USB webcam streams
            else if (currentStreamProtocol === 'usb') {
                const video = document.getElementById('cctvStream');
                return usbStream !== null &&
                    video.srcObject instanceof MediaStream &&
                    (video.readyState === 4 || video.readyState === 3);
            }

            return false;
        }


        // Show stream required alert
        function showStreamRequiredAlert(action) {
            showToast(`Please connect to camera stream before ${action}`, 'warning');
            // Also highlight the stream section
            const streamSection = document.querySelector('.stream-section');
            streamSection.style.animation = 'pulse 1s ease-in-out 3';
        }

        // Start recording function
        // Start recording function
        async function startRecording() {
            const streamType = currentStreamProtocol;
            if (!isAwbEntered()) {
                showAlert('Please enter AWB Number first', 'error');
                return;
            }

            if (!isStreamConnected()) {
                showStreamRequiredAlert('recording');
                return;
            }

            try {
                const awbNo = awbNoInput.value.trim();
                //  let streamUrl;
                //  let streamType = currentStreamProtocol; // http / rtsp / usb

                // üÜï USB branch
                if (currentStreamProtocol === 'usb') {
                    if (!usbStream) {
                        showToast('No USB webcam stream active', 'warning');
                        return;
                    }

                    usbRecordedChunks = [];
                    const options = { mimeType: 'video/webm; codecs=vp9' };
                    //   usbRecorder = new MediaRecorder(usbStream, { mimeType: 'video/webm' });
                    try {
                        usbRecorder = new MediaRecorder(usbStream, options);
                    } catch (e) {
                        console.log('Trying fallback MediaRecorder options:', e);
                        usbRecorder = new MediaRecorder(usbStream); // Use default options
                    }
                    usbRecorder.ondataavailable = event => {
                        if (event.data.size > 0) {
                            usbRecordedChunks.push(event.data);
                        }
                    };

                    // Upload to backend on stop
                    usbRecorder.onstop = async () => {
                        const blob = new Blob(usbRecordedChunks, { type: 'video/webm' });

                        const formData = new FormData();
                        formData.append('awbNo', awbNo);
                        formData.append('scannedData', currentScannedData || 'None');
                        formData.append('file', blob, `${awbNo}_${Date.now()}.webm`);
                        formData.append('streamType', 'usb');

                        try {
                            const response = await fetch('/api/save-usb-recording', {
                                method: 'POST',
                                body: formData
                            });
                            // const result = await response.json();

                            const result = await response.json();
                            if (result.success) {
                                showToast('Recording saved successfully', 'success');

                                // Show save dialog
                                pendingRecordingData = {
                                    tempKey: result.tempKey,
                                    scannedData: result.scannedData,
                                    awbNo: awbNo
                                };
                                showSaveRecordingDialog();
                            } else {
                                showToast('Failed to save recording: ' + result.error, 'error');
                            }
                        } catch (err) {
                            console.error('USB recording upload failed:', err);
                            showToast('USB recording upload error: ' + err.message, 'error');
                        }
                    };

                    usbRecorder.start(1000);
                    isRecording = true;

                    // Update UI
                    document.getElementById('recordOn').textContent = 'üî¥ Recording...';
                    document.getElementById('recordOn').disabled = true;
                    document.getElementById('recordOff').disabled = false;

                    showToast('USB Recording Started', 'success');
                    return;
                }

                // üåê Existing HTTP/RTSP workflow
                if (streamType === 'http') {
                    let cleanAddress = currentStreamAddress;
                    if (cleanAddress.includes('@')) {
                        cleanAddress = cleanAddress.split('@')[1];
                    }
                    streamUrl = `http://${cleanAddress}/video`;
                } else {
                    const streamPath = document.getElementById('streamPath').value.trim() || '/live/0/MAIN';
                    streamUrl = `rtsp://${currentStreamAddress}${streamPath}`;
                }

                console.log('üé¨ Starting recording with:', streamType, streamUrl);

                const recordBtn = document.getElementById('recordOn');
                recordBtn.textContent = 'Starting...';
                recordBtn.disabled = true;

                const response = await fetch('/api/start-recording', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        awbNo,
                        scannedData: currentScannedData,
                        streamUrl,
                        streamType
                    })
                });

                const result = await response.json();

                if (result.success) {
                    isRecording = true;
                    window.currentRecordingKey = result.tempKey;
                    recordBtn.textContent = 'üî¥ Recording...';
                    document.getElementById('recordOff').disabled = false;
                    document.getElementById('recordOff').textContent = '‚èπ Stop Recording';
                    showToast('Recording Started Successfully!', 'success');
                } else {
                    recordBtn.textContent = 'üî¥ Start Recording';
                    recordBtn.disabled = false;
                    showToast('Failed: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('Error starting recording:', error);
                const recordBtn = document.getElementById('recordOn');
                recordBtn.textContent = 'üî¥ Start Recording';
                recordBtn.disabled = false;
                showToast('Error starting recording: ' + error.message, 'error');
            }
        }

        // Stop recording function
        async function stopRecording() {
            // üÜï USB branch
            if (currentStreamProtocol === 'usb') {
                if (usbRecorder && usbRecorder.state === 'recording') {
                    usbRecorder.stop(); // upload handled in onstop above
                    isRecording = false;
                    //   window.currentRecordingKey = null;

                    // Update UI
                    document.getElementById('recordOn').disabled = false;
                    document.getElementById('recordOn').textContent = 'üî¥ Start Recording';
                    document.getElementById('recordOff').disabled = true;

                    showToast('Recording stopped', 'info');
                } else {
                    showToast('No USB recording in progress', 'warning');
                }
                return;
            }

            // üåê Existing HTTP/RTSP workflow
            try {
                const stopBtn = document.getElementById('recordOff');
                stopBtn.textContent = 'Stopping...';
                stopBtn.disabled = true;

                const response = await fetch('/api/stop-recording', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tempKey: window.currentRecordingKey })
                });
                const result = await response.json();

                if (result.success) {
                    isRecording = false;
                    window.currentRecordingKey = null;
                    document.getElementById('recordOn').disabled = false;
                    document.getElementById('recordOn').textContent = 'üî¥ Start Recording';
                    stopBtn.textContent = '‚èπ Stop Recording';

                    showToast('Recording stopped', 'success');

                    pendingRecordingData = {
                        tempKey: result.tempKey,
                        scannedData: result.scannedData,
                        awbNo: awbNoInput.value.trim()
                    };

                    showSaveRecordingDialog();
                } else {
                    stopBtn.textContent = '‚èπ Stop Recording';
                    stopBtn.disabled = false;
                    showToast('Failed to stop: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('Error stopping recording:', error);
                const stopBtn = document.getElementById('recordOff');
                stopBtn.textContent = '‚èπ Stop Recording';
                stopBtn.disabled = false;
                isRecording = false;
                showToast('Error stopping recording: ' + error.message, 'error');
            }
        }

        // Capture image function
        async function captureFromStream() {
            const streamType = currentStreamProtocol;
            if (isProcessing) return;

            if (!isAwbEntered()) {
                showAwbValidation();
                showAlert('Please enter AWB Number first', 'error');
                return;
            }

            if (!isStreamConnected()) {
                showStreamRequiredAlert('capturing image');
                return;
            }

            isProcessing = true;
            const captureBtn = document.getElementById('captureImage');
            const originalText = captureBtn.textContent;
            captureBtn.textContent = 'Capturing...';
            captureBtn.disabled = true;

            try {
                const awbNo = awbNoInput.value.trim();
                //    let streamUrl;
                //    let streamType = currentStreamProtocol;

                // üÜï USB branch
                if (currentStreamProtocol === 'usb') {
                    if (!usbStream) {
                        showToast('No USB webcam stream active', 'warning');
                        return;
                    }

                    const video = document.getElementById('cctvStream');
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;

                    const context = canvas.getContext('2d');
                    context.drawImage(video, 0, 0, canvas.width, canvas.height);

                    // Convert to blob and send to server
                    canvas.toBlob(async (blob) => {
                        const formData = new FormData();
                        formData.append('awbNo', awbNo);
                        formData.append('scannedData', currentScannedData || 'None');
                        formData.append('file', blob, `${awbNo}_${Date.now()}.png`);
                        formData.append('streamType', 'usb');

                        try {
                            const response = await fetch('/api/save-usb-image', {
                                method: 'POST',
                                body: formData
                            });

                            const result = await response.json();
                            if (result.success) {
                                showToast('Image captured', 'success');

                                pendingImageData = {
                                    awbNo: awbNo,
                                    tempKey: result.tempKey,
                                    scannedData: result.scannedData
                                };

                                showSaveImageDialog();
                            } else {
                                showToast('Failed to capture image: ' + result.error, 'error');
                            }
                        } catch (error) {
                            console.error('Error uploading image:', error);
                            showToast('Upload error: ' + error.message, 'error');
                        } finally {
                            isProcessing = false;
                            captureBtn.textContent = originalText;
                            captureBtn.disabled = false;
                        }
                    }, 'image/png');

                    return;
                }

                // üåê Existing HTTP/RTSP workflow (unchanged)
                if (currentStreamProtocol === 'http') {
                    let cleanAddress = currentStreamAddress;
                    if (cleanAddress.includes('@')) {
                        cleanAddress = cleanAddress.split('@')[1];
                    }
                    streamUrl = `http://${cleanAddress}/video`;
                } else {
                    const streamPath = document.getElementById('streamPath').value.trim() || '/live/0/MAIN';
                    let cleanAddress = currentStreamAddress;
                    if (cleanAddress.includes('@')) {
                        cleanAddress = cleanAddress.split('@')[1];
                    }

                    let credentials = '';
                    if (streamIPInput.value.includes('@')) {
                        credentials = streamIPInput.value.split('@')[0] + '@';
                    }

                    streamUrl = `rtsp://${credentials}${cleanAddress}${streamPath}`;
                }

                console.log('Capturing image from:', streamUrl, 'type:', streamType);

                const response = await fetch('/api/capture-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        awbNo: awbNo,
                        scannedData: currentScannedData,
                        streamUrl: streamUrl,
                        streamType: streamType
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showToast('Image captured', 'success');

                    pendingImageData = {
                        awbNo: awbNo,
                        tempKey: result.tempKey,
                        scannedData: result.scannedData
                    };

                    showSaveImageDialog();
                } else {
                    showToast('Failed to capture image: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('Error capturing image:', error);
                showToast('Error capturing image: ' + error.message, 'error');
            } finally {
                isProcessing = false;
                captureBtn.textContent = originalText;
                captureBtn.disabled = false;
            }
        }

        // Save recording function
        async function saveRecording() {
            if (!pendingRecordingData) {
                return;
            }

            try {
                saveRecordingBtn.disabled = true;
                saveRecordingBtn.textContent = 'üíæ Saving...';
                discardRecordingBtn.disabled = true;
                discardRecordingBtn.textContent = 'Discarding...';

                // INSTANT SUCCESS FEEDBACK (within 100ms)
                showToast('Video saved locally. Google Drive sync in progress...', 'success');

                // Show upload progress UI
                showUploadProgress(`${pendingRecordingData.awbNo}.mp4`, 'video');

                // Store temp data before making the request
                const tempData = { ...pendingRecordingData };
                pendingRecordingData = null;

                // Hide dialog immediately
                hideSaveRecordingDialog();


                // Send to server in background (will actually save)
                // Send to server in background
                fetch('/api/save-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        awbNo: tempData.awbNo,
                        tempKey: tempData.tempKey,
                        mediaType: 'video',
                        save: true
                    })
                })
                    .then(response => response.json())
                    .then(result => {
                        if (result.success) {
                            hideUploadProgress();
                            showToast('Google Drive sync completed!', 'success');
                        } else {
                            showUploadError(`${tempData.awbNo}.mp4`, result.error || 'Unknown error');
                        }
                    })
                    .catch(error => {
                        console.error('Upload error:', error);
                        showUploadError(`${tempData.awbNo}.mp4`, error.message);
                    });

            } catch (error) {
                console.error('Save error:', error);
                hideUploadProgress();
                showToast('Error saving video', 'error');
            }
        }

        // Discard recording function
        async function discardRecording() {
            if (!pendingRecordingData) {
                showToast('No recording data to discard', 'error');
                hideSaveRecordingDialog();
                return;
            }

            try {
                const tempData = { ...pendingRecordingData };
                pendingRecordingData = null;

                hideSaveRecordingDialog();
                showToast('Recording discarded', 'warning');

                discardRecordingBtn.disabled = true;
                discardRecordingBtn.textContent = 'Discarding...';

                // Don't show progress for discards
                fetch('/api/save-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        awbNo: tempData.awbNo,
                        tempKey: tempData.tempKey,
                        mediaType: 'video',
                        save: false
                    })
                }).catch(error => console.error('Discard error:', error));

            } catch (error) {
                console.error('Discard error:', error);
                showToast('Error discarding recording', 'error');
            }
        }

        // Save image function
        async function saveImage() {
            if (!pendingImageData) {
                return;
            }

            try {
                saveImageBtn.disabled = true;
                saveImageBtn.textContent = 'üíæ Saving...';
                discardImageBtn.disabled = true;

                // INSTANT SUCCESS FEEDBACK
                showToast('Image saved locally. Google Drive sync in progress...', 'success');


                // Show upload progress UI
                showUploadProgress(`${pendingImageData.awbNo}.jpg`, 'image');

                // Store temp data before making the request
                const tempData = { ...pendingImageData };
                pendingImageData = null;

                hideSaveImageDialog();

                // Background processing
                fetch('/api/save-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        awbNo: tempData.awbNo,
                        tempKey: tempData.tempKey,
                        mediaType: 'image',
                        save: true
                    })
                })
                    .then(response => response.json())
                    .then(result => {
                        if (result.success) {
                            hideUploadProgress();
                            showToast('Google Drive sync completed!', 'success');
                        } else {
                            showUploadError(`${tempData.awbNo}.jpg`, result.error || 'Unknown error');
                        }
                    })
                    .catch(error => {
                        console.error('Upload error:', error);
                        showUploadError(`${tempData.awbNo}.jpg`, error.message);
                    });

            } catch (error) {
                console.error('Save error:', error);
                hideUploadProgress();
                showToast('Error saving image', 'error');
            }
        }


        // Discard image function
        async function discardImage() {
            if (!pendingImageData) {
                showToast('No image data to discard', 'error');
                return;
            }

            try {
                const tempData = { ...pendingImageData };
                pendingImageData = null;

                hideSaveImageDialog();
                showToast('Image discarded', 'warning');

                fetch('/api/save-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        awbNo: tempData.awbNo,
                        tempKey: tempData.tempKey,
                        mediaType: 'image',
                        save: false
                    })
                }).catch(error => console.error('Discard error:', error));

            } catch (error) {
                console.error('Discard error:', error);
                showToast('Error discarding image', 'error');
            }
        }

        // Show image save dialog
        function showSaveImageDialog() {
            saveImageDialog.style.display = 'block';
            saveImageOverlay.style.display = 'block';

            // Enable both buttons immediately
            saveImageBtn.disabled = false;
            discardImageBtn.disabled = false;

            saveImageBtn.textContent = 'üíæ Save';
            discardImageBtn.textContent = 'üóë Discard';

            // Set up button handlers
            saveImageBtn.onclick = saveImage;
            discardImageBtn.onclick = discardImage;
        }

        // Hide save image dialog
        function hideSaveImageDialog() {
            saveImageDialog.style.display = 'none';
            saveImageOverlay.style.display = 'none';
        }

        // Enhanced stream connection function
        // In bad1.html - Replace the connectToStream function
        // Replace the entire connectToStream function with this:
        // Enhanced stream connection function
        async function connectToStream() {
            const streamIP = streamIPInput.value.trim();
            currentStreamProtocol = document.getElementById('streamProtocol').value;
            currentStreamPath = document.getElementById('streamPath').value.trim() ||
                (currentStreamProtocol === 'http' ? '/video' : '/live/0/MAIN');

            // üÜï USB handling BEFORE IP check
            if (currentStreamProtocol === 'usb') {
                startUsbStream();   // call the webcam function we wrote earlier
                return true;        // stop here, don't run IP validation
            }

            if (!streamIP) {
                showToast('Please enter IP address', 'warning');
                return false;
            }

            try {
                updateStreamStatus(StreamStatus.LOADING, 'Connecting...');

                if (currentStreamProtocol === 'http') {
                    // MJPEG stream
                    const formattedAddress = formatStreamAddress(streamIP);
                    const streamUrl = `/video-proxy?camera=${formattedAddress}&path=${encodeURIComponent(currentStreamPath)}&t=${Date.now()}`;

                    // Test connection first
                    const isConnected = await testStreamConnection(streamUrl);

                    if (isConnected) {
                        // Hide video, show image
                        document.getElementById('cctvStream').style.display = 'none';
                        document.getElementById('cameraStream').style.display = 'block';

                        cameraStream.src = streamUrl;
                        currentStreamAddress = formattedAddress;

                        // Store for persistence
                        window.currentStreamAddress = formattedAddress;
                        preserveStreamState();

                        await saveWorkingSessionData();
                        startStreamMonitoring();
                        return true;
                    }
                } else {
                    // RTSP stream - ALWAYS use HLS proxy, never try direct playback
                    const formattedAddress = formatStreamAddress(streamIP);
                    const rtspUrl = `rtsp://${formattedAddress}${currentStreamPath}`;

                    console.log('RTSP URL:', rtspUrl);

                    // Use the server proxy to convert RTSP to HLS
                    const proxyResponse = await fetch(`/api/rtsp-proxy?url=${encodeURIComponent(rtspUrl)}`);
                    const proxyData = await proxyResponse.json();

                    if (!proxyData.hlsUrl) {
                        throw new Error('Failed to create HLS stream');
                    }

                    // Set currentStreamAddress for RTSP streams too
                    currentStreamAddress = formattedAddress;
                    window.currentStreamAddress = formattedAddress;

                    // Hide image, show video
                    document.getElementById('cameraStream').style.display = 'none';
                    document.getElementById('cctvStream').style.display = 'block';

                    // Set up HLS.js for video playback
                    if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                        const video = document.getElementById('cctvStream');

                        // Destroy existing Hls instance if any
                        if (window.hlsInstance) {
                            window.hlsInstance.destroy();
                            delete window.hlsInstance;
                        }

                        window.hlsInstance = new Hls({
                            enableWorker: true,
                            lowLatencyMode: true,
                            backBufferLength: 10,
                            maxBufferLength: 15,
                            maxMaxBufferLength: 20,
                            maxBufferSize: 10 * 1000 * 1000,
                            maxBufferHole: 0.5,
                            maxFragLookUpTolerance: 0.1,
                            liveSyncDurationCount: 2,
                            liveMaxLatencyDurationCount: 5,
                            ebug: true, // Enable debug logging
                            enableSoftwareAES: true
                        });

                        const hlsUrl = `${window.location.origin}${proxyData.hlsUrl}`;
                        console.log('Full HLS URL:', hlsUrl);

                        // Test if the HLS URL is accessible
                        try {
                            const testResponse = await fetch(hlsUrl, { method: 'HEAD' });
                            if (!testResponse.ok) {
                                throw new Error(`HLS URL not accessible: ${testResponse.status}`);
                            }
                            console.log('HLS URL is accessible');
                        } catch (error) {
                            console.error('HLS URL test failed:', error);
                            //  showDebugInfo(`HLS URL test failed: ${error.message}`);
                            throw error;
                        }

                        window.hlsInstance.loadSource(hlsUrl);
                        window.hlsInstance.attachMedia(video);

                        // Add more event listeners for better debugging
                        window.hlsInstance.on(Hls.Events.MANIFEST_LOADED, (event, data) => {
                            console.log('Manifest loaded:', data);
                            //   showDebugInfo('Manifest loaded, starting playback');
                        });

                        window.hlsInstance.on(Hls.Events.LEVEL_LOADED, (event, data) => {
                            console.log('Level loaded:', data);
                        });

                        window.hlsInstance.on(Hls.Events.FRAG_LOADED, (event, data) => {
                            console.log('Fragment loaded:', data.frag.url);
                            // showDebugInfo(`Fragment loaded: ${data.frag.url}`);
                        });

                        window.hlsInstance.on(Hls.Events.ERROR, (event, data) => {
                            console.error('HLS error event:', data);
                            //   showDebugInfo(`HLS Error: ${data.type} - ${data.details}`);

                            if (data.fatal) {
                                switch (data.type) {
                                    case Hls.ErrorTypes.NETWORK_ERROR:
                                        console.log('Network error, trying to recover...');
                                        //  showDebugInfo('Network error, recovering...');
                                        window.hlsInstance.startLoad();
                                        break;
                                    case Hls.ErrorTypes.MEDIA_ERROR:
                                        console.log('Media error, trying to recover...');
                                        showDebugInfo('Media error, recovering...');
                                        window.hlsInstance.recoverMediaError();
                                        break;
                                    default:
                                        console.log('Unrecoverable error');
                                        //   showDebugInfo('Unrecoverable error, restarting...');
                                        window.hlsInstance.destroy();
                                        // Try to reconnect after a delay
                                        setTimeout(() => {
                                            connectToStream();
                                        }, 3000);
                                        break;
                                }
                            }
                        });

                        return true;
                    } else if (document.getElementById('cctvStream').canPlayType('application/vnd.apple.mpegurl')) {
                        // Native HLS support (Safari)
                        const hlsUrl = proxyData.hlsUrl;
                        console.log('Using native HLS with URL:', hlsUrl);

                        const video = document.getElementById('cctvStream');
                        video.src = hlsUrl;

                        video.addEventListener('loadedmetadata', () => {
                            console.log('Native HLS metadata loaded');
                            video.play().catch(e => {
                                console.log('Autoplay prevented:', e);
                                video.controls = true;
                            });

                            updateStreamStatus(StreamStatus.CONNECTED, 'Connected (RTSP Live)');
                            currentStreamAddress = formattedAddress;
                            window.currentStreamAddress = formattedAddress;
                            window.currentStreamProtocol = 'rtsp';
                            preserveStreamState();
                            startStreamMonitoring();
                        });

                        video.addEventListener('error', (e) => {
                            console.error('Native HLS error:', e);
                            updateStreamStatus(StreamStatus.ERROR, 'Playback Error');
                        });

                        return true;
                    } else {
                        throw new Error('HLS not supported in this browser');
                    }
                }
            } catch (error) {
                console.error('Stream connection error:', error);
                updateStreamStatus(StreamStatus.ERROR, 'Connection Failed: ' + error.message);
                currentStreamAddress = '';
                return false;
            }
        }


        // Add this function to display debug info
        function showDebugInfo(message) {
            // Create or update debug element
            let debugEl = document.getElementById('streamDebugInfo');
            if (!debugEl) {
                debugEl = document.createElement('div');
                debugEl.id = 'streamDebugInfo';
                debugEl.style.cssText = 'position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; z-index: 10000; font-size: 12px; max-width: 400px; max-height: 200px; overflow: auto;';
                document.body.appendChild(debugEl);
            }

            // Add timestamp and limit to 10 messages
            const timestamp = new Date().toLocaleTimeString();
            const newMessage = `[${timestamp}] ${message}`;

            let messages = debugEl.innerHTML.split('<br>');
            messages.unshift(newMessage);
            if (messages.length > 10) {
                messages = messages.slice(0, 10);
            }

            debugEl.innerHTML = messages.join('<br>');
            console.log('DEBUG:', message);
        }

        // Update the connectToStream function to include debug info
        // Add this at the beginning of the RTSP section:
        showDebugInfo(`Connecting to RTSP: ${rtspUrl}`);

        // Add this after successful HLS setup:
        showDebugInfo(`HLS stream started: ${hlsUrl}`);

        // Add this on errors:
        showDebugInfo(`Error: ${error.message}`);


        // Add this function to detect browser capabilities
        function checkRTSPSupport() {
            const video = document.createElement('video');
            const canPlayRTSP = video.canPlayType('application/x-rtsp');

            console.log('RTSP support:', canPlayRTSP);
            return canPlayRTSP === 'maybe' || canPlayRTSP === 'probably';
        }

        // Add this function to ensure fresh streams
        function ensureFreshStream() {
            // Clear any existing stream state
            localStorage.removeItem('streamStatePreserve');

            // Force reload HLS.js if it exists
            if (window.hlsInstance) {
                window.hlsInstance.destroy();
                delete window.hlsInstance;
            }

            // Clear video elements
            document.getElementById('cctvStream').src = '';
            document.getElementById('cameraStream').src = '';

            console.log('Ensured fresh stream state');
        }

        // Call this when changing stream type or IP
        document.getElementById('streamProtocol').addEventListener('change', ensureFreshStream);
        document.getElementById('streamIP').addEventListener('input', function () {
            // Debounce this to avoid too many calls
            clearTimeout(window.ipChangeTimeout);
            window.ipChangeTimeout = setTimeout(ensureFreshStream, 1000);
        });

        // Add this function to check HLS support
        function checkHLSSupport() {
            const video = document.createElement('video');
            const canPlayHLS = video.canPlayType('application/vnd.apple.mpegurl') ||
                (typeof Hls !== 'undefined' && Hls.isSupported());

            console.log('HLS support:', canPlayHLS);
            return canPlayHLS;
        }

        // Call these on page load
        document.addEventListener('DOMContentLoaded', function () {
            const rtspSupported = checkRTSPSupport();
            const hlsSupported = checkHLSSupport();

            console.log('Stream capabilities - RTSP:', rtspSupported, 'HLS:', hlsSupported);

            // Store for later use
            window.browserCapabilities = {
                rtsp: rtspSupported,
                hls: hlsSupported
            };
        });

        // Add this function to test RTSP connection without using fetch
        async function testRTSPConnection(streamUrl) {
            return new Promise((resolve) => {
                // Use FFprobe to check if the RTSP stream is accessible
                ffmpeg.ffprobe(streamUrl, { timeout: 5000 }, (err, metadata) => {
                    if (err) {
                        console.error('RTSP connection test failed:', err);
                        resolve(false);
                    } else {
                        console.log('RTSP connection test successful');
                        resolve(true);
                    }
                });
            });
        }

        // Add this function to handle stream reconnection
        async function reconnectStream() {
            const streamState = localStorage.getItem('streamStatePreserve');
            if (streamState) {
                try {
                    const state = JSON.parse(streamState);

                    // Only reconnect if the state is recent (within 2 minutes)
                    if (Date.now() - state.timestamp < 120000) {
                        const ipParts = state.address.split(':');
                        streamIPInput.value = ipParts[0];

                        // Set the protocol if available
                        if (state.protocol) {
                            document.getElementById('streamProtocol').value = state.protocol;
                            currentStreamProtocol = state.protocol;

                            if (state.protocol === 'rtsp' && state.path) {
                                document.getElementById('streamPath').value = state.path;
                                document.getElementById('streamPath').style.display = 'block';
                            } else {
                                document.getElementById('streamPath').style.display = 'none';
                            }
                        }

                        // Auto-connect after a short delay
                        setTimeout(() => {
                            if (window.connectToStream) {
                                window.connectToStream();
                            }
                        }, 300);
                    }
                } catch (e) {
                    console.error('Error parsing stream state:', e);
                }
            }
        }

        // Add this function to show stream-specific errors
        function showStreamError(message, type) {
            const errorMessage = type === 'rtsp'
                ? `${message}. Note: RTSP streams may require special server configuration.`
                : message;

            showToast(errorMessage, 'error');

            // Also update the stream status
            updateStreamStatus(StreamStatus.ERROR, 'Connection Failed');
        }



        // Add this improved test function:
        async function testStreamConnection(url) {
            // For RTSP streams, use a different testing approach
            if (url.startsWith('rtsp://')) {
                return testRTSPConnection(url);
            }

            // For HTTP streams, use the existing method
            return new Promise((resolve) => {
                const testImg = new Image();
                let resolved = false;

                const timeout = setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        console.log('Stream test timeout');
                        resolve(false);
                    }
                }, 8000);

                testImg.onload = () => {
                    if (!resolved) {
                        resolved = true;
                        clearTimeout(timeout);
                        console.log('Stream test successful');
                        resolve(true);
                    }
                };

                testImg.onerror = (e) => {
                    if (!resolved) {
                        resolved = true;
                        clearTimeout(timeout);
                        console.log('Stream test failed:', e);
                        resolve(false);
                    }
                };
                const separator = url.includes('?') ? '&' : '?';
                testImg.src = url + separator + 'test=' + Date.now();
            });
        }

        document.getElementById('savebtn').addEventListener('click', async function () {
            const awbNo = awbNoInput.value.trim();
            const orderNo = document.getElementById('orderNo').value.trim();

            // Get the additional information from the dropdowns
            additionalInfo.courierName = document.getElementById('courierName').value;
            additionalInfo.returnType = document.getElementById('returnType').value;
            additionalInfo.opsRemarks = document.getElementById('opsRemarks').value;
            additionalInfo.channelName = document.getElementById('Channel Name').value;


            if (!awbNo) {
                showAlert('Please enter AWB Number before saving.', 'error');
                return;
            }

            if (!orderNo) {
                showAlert('Please enter Order No before saving.', 'error');
                return;
            }

            const totalItems = tempData.good.length + tempData.bad.length +
                tempData.used.length + tempData.wrong.length;

            if (totalItems === 0) {
                showAlert('No items to save. Please scan some items first.', 'error');
                return;
            }

            // Validate that all required fields are filled
            if (!additionalInfo.courierName || !additionalInfo.returnType || !additionalInfo.opsRemarks || !additionalInfo.channelName) {
                showAlert('Please fill all additional information fields (Courier Name, Return Type, OPS Remarks).', 'error');
                return;
            }

            showDeleteConfirmation(
                `Are you sure you want to save ${totalItems} items for AWB ${awbNo}?`,
                async function () {
                    try {
                        // PRESERVE STREAM STATE BEFORE SAVE
                        const wasStreamConnected = currentStreamAddress !== '';
                        const preservedStreamAddress = currentStreamAddress;
                        const preservedStreamStatus = lastStreamCheck;

                        // Disable button and show loading
                        const saveBtn = document.getElementById("savebtn");
                        saveBtn.disabled = true;
                        saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Saving...';

                        // üî• SKU pairs data collect pannunga
                        const skuPairs = [];
                        document.querySelectorAll('#skuPairsList li').forEach(li => {
                            const text = li.textContent;
                            const match = text.match(/System: (.+) ‚Üí Physical: (.+)/);
                            if (match) {
                                skuPairs.push({
                                    systemSku: match[1],
                                    physicalSku: match[2]
                                });
                            }
                        });

                        // Prepare category data
                        const categoryData = {
                            good: { count: tempData.good.length, eans: tempData.good },
                            bad: { count: tempData.bad.length, eans: tempData.bad },
                            used: { count: tempData.used.length, eans: tempData.used },
                            wrong: { count: tempData.wrong.length, eans: tempData.wrong }
                        };

                        const awbRecordings = recordings.filter(r => r.awbNo === awbNo);

                        // Enhanced payload with all required data
                        const payload = {
                            awbNo: awbNo,
                            orderId: orderNo,   // üî• NEW FIELD
                            categoryData: categoryData,
                            recordings: awbRecordings,
                            additionalInfo: additionalInfo,
                            skuPairs: skuPairs,
                            // Add these for Google Sheet update
                            courierName: additionalInfo.courierName,
                            returnType: additionalInfo.returnType,
                            opsRemarks: additionalInfo.opsRemarks,
                            channelName: additionalInfo.channelName,
                            userComment: additionalInfo.userComment
                        };

                        console.log("üì§ Sending payload:", payload);

                        const response = await fetch('/api/save-inventory', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(payload)
                        });

                        const result = await response.json();
                        console.log("üì• Server response:", result);

                        if (result.success) {
                            // Clear only the form data
                            tempData = { good: [], bad: [], used: [], wrong: [] };
                            recordings = recordings.filter(r => r.awbNo !== awbNo);
                            currentScannedData = '';
                            updateAllLists();

                            // Clear AWB input and update display
                            awbNoInput.value = '';
                            currentAwbDisplay.textContent = 'None';
                            enableCategoryInputs();

                            // Clear additional info dropdowns
                            document.getElementById('courierName').value = '';
                            document.getElementById('returnType').value = '';
                            document.getElementById('opsRemarks').value = '';
                            document.getElementById('channelName').value = '';
                            document.getElementById('orderNo').value = '';
                            additionalInfo = { courierName: '', returnType: '', opsRemarks: '', channelName: '', orderNo: '' };

                            // RESTORE STREAM STATE AFTER SAVE
                            if (wasStreamConnected && preservedStreamAddress) {
                                currentStreamAddress = preservedStreamAddress;
                                lastStreamCheck = preservedStreamStatus;

                                // Ensure stream src is maintained
                                if (cameraStream.src === '' || !cameraStream.src.includes(preservedStreamAddress)) {
                                    cameraStream.src = `http://${preservedStreamAddress}/video?t=${Date.now()}`;
                                }

                                // Restore UI status
                                updateStreamStatus(StreamStatus.CONNECTED, 'Connected');

                                // Resume monitoring if it was stopped
                                if (!streamCheckInterval) {
                                    startStreamMonitoring();
                                }

                                console.log('Stream state preserved after save');
                            }

                            // Update working session on server
                            await saveWorkingSessionData();

                            // Reload saved data to update data management section
                            await loadSavedData();

                            showAlert('‚úÖ Data saved successfully to both database and Google Sheet!', 'success');
                        } else {
                            showAlert('‚ùå Failed to save data: ' + result.message, 'error');
                        }
                    } catch (error) {
                        console.error('Error saving data:', error);
                        showAlert('‚ùå Error saving data: ' + error.message, 'error');
                    } finally {
                        // Re-enable button
                        const saveBtn = document.getElementById("savebtn");
                        saveBtn.disabled = false;
                        saveBtn.innerHTML = "Save Data";
                        resetActivityTimer();
                    }
                },
                true
            );
        });

        async function saveRecordingData() {
            // Media files create pannuratha?
            const mediaFiles = [];

            // Video file irundha
            if (recordedVideoBlob) {
                const videoFile = await uploadToServer(recordedVideoBlob, 'video');
                mediaFiles.push({
                    type: 'video',
                    driveLink: videoFile.url,
                    uploadDate: new Date()
                });
            }

            // Image files irundha
            if (capturedImages.length > 0) {
                for (const imageBlob of capturedImages) {
                    const imageFile = await uploadToServer(imageBlob, 'image');
                    mediaFiles.push({
                        type: 'image',
                        driveLink: imageFile.url,
                        uploadDate: new Date()
                    });
                }
            }

            // Database ku save pannu
            const inventoryData = {
                awbNo: awbNumber,
                timestamp: new Date(),
                username: operatorName,
                mediaFiles: mediaFiles, // ‚úÖ Ithu important!
                categoryData: {
                    good: { eans: goodEANs, count: goodEANs.length },
                    bad: { eans: badEANs, count: badEANs.length },
                    used: { eans: usedEANs, count: usedEANs.length },
                    wrong: { eans: wrongEANs, count: wrongEANs.length }
                }
            };

            const response = await fetch('/api/save-inventory', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(inventoryData)
            });

            return response.json();
        }


        function createTestRecordWithMedia() {
            const testData = {
                _id: 'test_with_media',
                awbNo: 'TEST123456',
                timestamp: new Date(),
                username: 'test_user',
                mediaFiles: [
                    {
                        type: 'image',
                        driveLink: 'https://picsum.photos/300/200', // Sample image
                        uploadDate: new Date()
                    },
                    {
                        type: 'video',
                        driveLink: 'https://sample-videos.com/zip/10/mp4/SampleVideo_1280x720_1mb.mp4', // Sample video
                        uploadDate: new Date()
                    }
                ],
                categoryData: {
                    good: { eans: ['1234567890123'], count: 1 },
                    bad: { eans: [], count: 0 },
                    used: { eans: [], count: 0 },
                    wrong: { eans: [], count: 0 }
                },
                additionalInfo: {
                    courierName: 'Test Courier',
                    returnType: 'Exchange',
                    opsRemarks: 'Test record with media'
                }
            };

            // Add to current data
            allInventoryData.unshift(testData);
            filteredData.unshift(testData);

            console.log('‚úÖ Test record created with media files');
            displayData();

            // Show details of test record
            setTimeout(() => {
                showDetails('test_with_media');
            }, 1000);
        }
        createTestRecordWithMedia()


        async function checkDatabaseStructure() {
            try {
                const response = await fetch('/api/get-inventory');
                const result = await response.json();

                if (result.success && result.data.length > 0) {
                    const sampleItem = result.data[0];
                    console.log('üìä Database Item Structure:', {
                        hasMediaFiles: !!sampleItem.mediaFiles,
                        mediaFiles: sampleItem.mediaFiles,
                        allKeys: Object.keys(sampleItem)
                    });

                    // Check all items
                    result.data.forEach((item, index) => {
                        console.log(`Item ${index}:`, {
                            awb: item.awbNo,
                            hasMedia: !!item.mediaFiles,
                            mediaCount: item.mediaFiles ? item.mediaFiles.length : 0
                        });
                    });
                }
            } catch (error) {
                console.error('Database check error:', error);
            }
        }
        checkDatabaseStructure()

        // Add this function to bad1.html
        async function loadOrganizationDropdowns() {
            try {
                const response = await fetch('/api/get-dropdown-options');
                const result = await response.json();

                if (result.success) {
                    populateDropdown('courierName', result.courierName);
                    populateDropdown('returnType', result.returnType);
                    populateDropdown('opsRemarks', result.opsRemarks);
                    populateDropdown('channelName', result.channelName);
                } else {
                    console.error('Failed to load dropdowns:', result.error);
                    populateDefaultDropdowns();
                }
            } catch (error) {
                console.error('Error loading organization dropdowns:', error);
                populateDefaultDropdowns();
            }
        }

        function populateDropdown(elementId, options) {
            const dropdown = document.getElementById(elementId);
            if (dropdown) {
                // Clear existing options except the first one
                dropdown.innerHTML = '<option value="">Select ' + elementId.replace(/([A-Z])/g, ' $1') + '</option>';

                options.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option;
                    optionElement.textContent = option;
                    dropdown.appendChild(optionElement);
                });
            }
        }

        function populateDefaultDropdowns() {
            const defaultOptions = {
                courierName: ['Amazon', 'Delhivery', 'DTDC', 'Other'],
                returnType: ['RTO', 'RVP', 'Other'],
                opsRemarks: ['Good', 'Damaged', 'Missing Items', 'Other'],
                channelName: ['Shopify', 'Amazon', 'Flipkart', 'Other']
            };

            populateDropdown('courierName', defaultOptions.courierName);
            populateDropdown('returnType', defaultOptions.returnType);
            populateDropdown('opsRemarks', defaultOptions.opsRemarks);
            populateDropdown('channelName', defaultOptions.channelName);
        }
        // bad1.html la add this function
        function openVideoSettings() {
            window.location.href = '/video-settings.html';
        }

        async function updateDropdownsFromSettings() {
            try {
                const response = await fetch('/api/get-dropdown-options');
                const result = await response.json();

                if (result.success) {
                    // Update all dropdowns
                    updateDropdown('courierName', result.courierName);
                    updateDropdown('returnType', result.returnType);
                    updateDropdown('opsRemarks', result.opsRemarks);
                    updateDropdown('channelName', result.channelName);

                    console.log('‚úÖ Dropdowns updated with latest settings');
                } else {
                    console.error('Failed to update dropdowns:', result.error);
                }
            } catch (error) {
                console.error('Error updating dropdowns:', error);
            }
        }

        function updateDropdown(selectId, options) {
            const select = document.getElementById(selectId);
            if (select) {
                // Clear existing options (except first empty option)
                while (select.options.length > 1) {
                    select.remove(1);
                }

                // Add new options
                options.forEach(option => {
                    const opt = document.createElement('option');
                    opt.value = option;
                    opt.textContent = option;
                    select.appendChild(opt);
                });
            }
        }
        // Page load la call pannu
        document.addEventListener('DOMContentLoaded', function () {
            updateDropdownsFromSettings();
        });
        // User role check function
        async function loadUserInfo() {
            try {
                const response = await fetch('/api/get-user-info');
                const userData = await response.json();

                if (userData.success) {
                    const userRole = userData.role; // 'user', 'admin', 'super_admin'
                    toggleSettingsButtons(userRole);
                }
            } catch (error) {
                console.error('Error fetching user info:', error);
                // Default ah user role ah assume panniko
                toggleSettingsButtons('user');
            }
        }
        // Buttons show/hide panra function
        function toggleSettingsButtons(userRole) {
            const driveSettingsBtn = document.querySelector('button[onclick*="drive-settings"]');
            const videoSettingsBtn = document.querySelector('button[onclick*="openVideoSettings"]');

            // Admin & Super Admin ku mattum than buttons show agum
            if (userRole === 'admin' || userRole === 'super_admin') {
                driveSettingsBtn.style.display = 'block';
                videoSettingsBtn.style.display = 'block';
            } else {
                // Normal user ku buttons hide
                driveSettingsBtn.style.display = 'none';
                videoSettingsBtn.style.display = 'none';
            }
        }
    </script>
</body>

</html>